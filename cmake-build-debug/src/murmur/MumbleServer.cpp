//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `MumbleServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <MumbleServer.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <Ice/SliceChecksums.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::MumbleServer::Tree> iceC_MumbleServer_Tree_init("::MumbleServer::Tree");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::MurmurException> iceC_MumbleServer_MurmurException_init("::MumbleServer::MurmurException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidSessionException> iceC_MumbleServer_InvalidSessionException_init("::MumbleServer::InvalidSessionException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidChannelException> iceC_MumbleServer_InvalidChannelException_init("::MumbleServer::InvalidChannelException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidServerException> iceC_MumbleServer_InvalidServerException_init("::MumbleServer::InvalidServerException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::ServerBootedException> iceC_MumbleServer_ServerBootedException_init("::MumbleServer::ServerBootedException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::ServerFailureException> iceC_MumbleServer_ServerFailureException_init("::MumbleServer::ServerFailureException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidUserException> iceC_MumbleServer_InvalidUserException_init("::MumbleServer::InvalidUserException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidTextureException> iceC_MumbleServer_InvalidTextureException_init("::MumbleServer::InvalidTextureException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidCallbackException> iceC_MumbleServer_InvalidCallbackException_init("::MumbleServer::InvalidCallbackException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidSecretException> iceC_MumbleServer_InvalidSecretException_init("::MumbleServer::InvalidSecretException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::NestingLimitException> iceC_MumbleServer_NestingLimitException_init("::MumbleServer::NestingLimitException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::WriteOnlyException> iceC_MumbleServer_WriteOnlyException_init("::MumbleServer::WriteOnlyException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::MumbleServer::InvalidInputDataException> iceC_MumbleServer_InvalidInputDataException_init("::MumbleServer::InvalidInputDataException");

const ::std::string iceC_MumbleServer_ServerCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerCallback"
};
const ::std::string iceC_MumbleServer_ServerCallback_ops[] =
{
    "channelCreated",
    "channelRemoved",
    "channelStateChanged",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "userConnected",
    "userDisconnected",
    "userStateChanged",
    "userTextMessage"
};
const ::std::string iceC_MumbleServer_ServerCallback_userConnected_name = "userConnected";
const ::std::string iceC_MumbleServer_ServerCallback_userDisconnected_name = "userDisconnected";
const ::std::string iceC_MumbleServer_ServerCallback_userStateChanged_name = "userStateChanged";
const ::std::string iceC_MumbleServer_ServerCallback_userTextMessage_name = "userTextMessage";
const ::std::string iceC_MumbleServer_ServerCallback_channelCreated_name = "channelCreated";
const ::std::string iceC_MumbleServer_ServerCallback_channelRemoved_name = "channelRemoved";
const ::std::string iceC_MumbleServer_ServerCallback_channelStateChanged_name = "channelStateChanged";

const ::std::string iceC_MumbleServer_ServerContextCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerContextCallback"
};
const ::std::string iceC_MumbleServer_ServerContextCallback_ops[] =
{
    "contextAction",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_MumbleServer_ServerContextCallback_contextAction_name = "contextAction";

const ::std::string iceC_MumbleServer_ServerAuthenticator_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerAuthenticator"
};
const ::std::string iceC_MumbleServer_ServerAuthenticator_ops[] =
{
    "authenticate",
    "getInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId"
};
const ::std::string iceC_MumbleServer_ServerAuthenticator_authenticate_name = "authenticate";
const ::std::string iceC_MumbleServer_ServerAuthenticator_getInfo_name = "getInfo";
const ::std::string iceC_MumbleServer_ServerAuthenticator_nameToId_name = "nameToId";
const ::std::string iceC_MumbleServer_ServerAuthenticator_idToName_name = "idToName";
const ::std::string iceC_MumbleServer_ServerAuthenticator_idToTexture_name = "idToTexture";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_ids[3] =
{
    "::Ice::Object",
    "::MumbleServer::ServerAuthenticator",
    "::MumbleServer::ServerUpdatingAuthenticator"
};
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_ops[] =
{
    "authenticate",
    "getInfo",
    "getRegisteredUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId",
    "registerUser",
    "setInfo",
    "setTexture",
    "unregisterUser"
};
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name = "registerUser";
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name = "unregisterUser";
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name = "getRegisteredUsers";
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name = "setInfo";
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name = "setTexture";

const ::std::string iceC_MumbleServer_Server_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::Server"
};
const ::std::string iceC_MumbleServer_Server_ops[] =
{
    "addCallback",
    "addChannel",
    "addContextCallback",
    "addUserToGroup",
    "delete",
    "effectivePermissions",
    "getACL",
    "getAllConf",
    "getBans",
    "getCertificateList",
    "getChannelState",
    "getChannels",
    "getConf",
    "getListenerVolumeAdjustment",
    "getListeningChannels",
    "getListeningUsers",
    "getLog",
    "getLogLen",
    "getRegisteredUsers",
    "getRegistration",
    "getState",
    "getTexture",
    "getTree",
    "getUptime",
    "getUserIds",
    "getUserNames",
    "getUsers",
    "hasPermission",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "id",
    "isListening",
    "isRunning",
    "kickUser",
    "redirectWhisperGroup",
    "registerUser",
    "removeCallback",
    "removeChannel",
    "removeContextCallback",
    "removeUserFromGroup",
    "sendMessage",
    "sendMessageChannel",
    "sendWelcomeMessage",
    "setACL",
    "setAuthenticator",
    "setBans",
    "setChannelState",
    "setConf",
    "setListenerVolumeAdjustment",
    "setState",
    "setSuperuserPassword",
    "setTexture",
    "start",
    "startListening",
    "stop",
    "stopListening",
    "unregisterUser",
    "updateCertificate",
    "updateRegistration",
    "verifyPassword"
};
const ::std::string iceC_MumbleServer_Server_isRunning_name = "isRunning";
const ::std::string iceC_MumbleServer_Server_start_name = "start";
const ::std::string iceC_MumbleServer_Server_stop_name = "stop";
const ::std::string iceC_MumbleServer_Server_delete_name = "delete";
const ::std::string iceC_MumbleServer_Server_id_name = "id";
const ::std::string iceC_MumbleServer_Server_addCallback_name = "addCallback";
const ::std::string iceC_MumbleServer_Server_removeCallback_name = "removeCallback";
const ::std::string iceC_MumbleServer_Server_setAuthenticator_name = "setAuthenticator";
const ::std::string iceC_MumbleServer_Server_getConf_name = "getConf";
const ::std::string iceC_MumbleServer_Server_getAllConf_name = "getAllConf";
const ::std::string iceC_MumbleServer_Server_setConf_name = "setConf";
const ::std::string iceC_MumbleServer_Server_setSuperuserPassword_name = "setSuperuserPassword";
const ::std::string iceC_MumbleServer_Server_getLog_name = "getLog";
const ::std::string iceC_MumbleServer_Server_getLogLen_name = "getLogLen";
const ::std::string iceC_MumbleServer_Server_getUsers_name = "getUsers";
const ::std::string iceC_MumbleServer_Server_getChannels_name = "getChannels";
const ::std::string iceC_MumbleServer_Server_getCertificateList_name = "getCertificateList";
const ::std::string iceC_MumbleServer_Server_getTree_name = "getTree";
const ::std::string iceC_MumbleServer_Server_getBans_name = "getBans";
const ::std::string iceC_MumbleServer_Server_setBans_name = "setBans";
const ::std::string iceC_MumbleServer_Server_kickUser_name = "kickUser";
const ::std::string iceC_MumbleServer_Server_getState_name = "getState";
const ::std::string iceC_MumbleServer_Server_setState_name = "setState";
const ::std::string iceC_MumbleServer_Server_sendMessage_name = "sendMessage";
const ::std::string iceC_MumbleServer_Server_hasPermission_name = "hasPermission";
const ::std::string iceC_MumbleServer_Server_effectivePermissions_name = "effectivePermissions";
const ::std::string iceC_MumbleServer_Server_addContextCallback_name = "addContextCallback";
const ::std::string iceC_MumbleServer_Server_removeContextCallback_name = "removeContextCallback";
const ::std::string iceC_MumbleServer_Server_getChannelState_name = "getChannelState";
const ::std::string iceC_MumbleServer_Server_setChannelState_name = "setChannelState";
const ::std::string iceC_MumbleServer_Server_removeChannel_name = "removeChannel";
const ::std::string iceC_MumbleServer_Server_addChannel_name = "addChannel";
const ::std::string iceC_MumbleServer_Server_sendMessageChannel_name = "sendMessageChannel";
const ::std::string iceC_MumbleServer_Server_getACL_name = "getACL";
const ::std::string iceC_MumbleServer_Server_setACL_name = "setACL";
const ::std::string iceC_MumbleServer_Server_addUserToGroup_name = "addUserToGroup";
const ::std::string iceC_MumbleServer_Server_removeUserFromGroup_name = "removeUserFromGroup";
const ::std::string iceC_MumbleServer_Server_redirectWhisperGroup_name = "redirectWhisperGroup";
const ::std::string iceC_MumbleServer_Server_getUserNames_name = "getUserNames";
const ::std::string iceC_MumbleServer_Server_getUserIds_name = "getUserIds";
const ::std::string iceC_MumbleServer_Server_registerUser_name = "registerUser";
const ::std::string iceC_MumbleServer_Server_unregisterUser_name = "unregisterUser";
const ::std::string iceC_MumbleServer_Server_updateRegistration_name = "updateRegistration";
const ::std::string iceC_MumbleServer_Server_getRegistration_name = "getRegistration";
const ::std::string iceC_MumbleServer_Server_getRegisteredUsers_name = "getRegisteredUsers";
const ::std::string iceC_MumbleServer_Server_verifyPassword_name = "verifyPassword";
const ::std::string iceC_MumbleServer_Server_getTexture_name = "getTexture";
const ::std::string iceC_MumbleServer_Server_setTexture_name = "setTexture";
const ::std::string iceC_MumbleServer_Server_getUptime_name = "getUptime";
const ::std::string iceC_MumbleServer_Server_updateCertificate_name = "updateCertificate";
const ::std::string iceC_MumbleServer_Server_startListening_name = "startListening";
const ::std::string iceC_MumbleServer_Server_stopListening_name = "stopListening";
const ::std::string iceC_MumbleServer_Server_isListening_name = "isListening";
const ::std::string iceC_MumbleServer_Server_getListeningChannels_name = "getListeningChannels";
const ::std::string iceC_MumbleServer_Server_getListeningUsers_name = "getListeningUsers";
const ::std::string iceC_MumbleServer_Server_getListenerVolumeAdjustment_name = "getListenerVolumeAdjustment";
const ::std::string iceC_MumbleServer_Server_setListenerVolumeAdjustment_name = "setListenerVolumeAdjustment";
const ::std::string iceC_MumbleServer_Server_sendWelcomeMessage_name = "sendWelcomeMessage";

const ::std::string iceC_MumbleServer_MetaCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::MetaCallback"
};
const ::std::string iceC_MumbleServer_MetaCallback_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "started",
    "stopped"
};
const ::std::string iceC_MumbleServer_MetaCallback_started_name = "started";
const ::std::string iceC_MumbleServer_MetaCallback_stopped_name = "stopped";

const ::std::string iceC_MumbleServer_Meta_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::Meta"
};
const ::std::string iceC_MumbleServer_Meta_ops[] =
{
    "addCallback",
    "getAllServers",
    "getBootedServers",
    "getDefaultConf",
    "getServer",
    "getSlice",
    "getSliceChecksums",
    "getUptime",
    "getVersion",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newServer",
    "removeCallback"
};
const ::std::string iceC_MumbleServer_Meta_getServer_name = "getServer";
const ::std::string iceC_MumbleServer_Meta_newServer_name = "newServer";
const ::std::string iceC_MumbleServer_Meta_getBootedServers_name = "getBootedServers";
const ::std::string iceC_MumbleServer_Meta_getAllServers_name = "getAllServers";
const ::std::string iceC_MumbleServer_Meta_getDefaultConf_name = "getDefaultConf";
const ::std::string iceC_MumbleServer_Meta_getVersion_name = "getVersion";
const ::std::string iceC_MumbleServer_Meta_addCallback_name = "addCallback";
const ::std::string iceC_MumbleServer_Meta_removeCallback_name = "removeCallback";
const ::std::string iceC_MumbleServer_Meta_getUptime_name = "getUptime";
const ::std::string iceC_MumbleServer_Meta_getSlice_name = "getSlice";
const ::std::string iceC_MumbleServer_Meta_getSliceChecksums_name = "getSliceChecksums";

}

MumbleServer::MurmurException::~MurmurException()
{
}

const ::std::string&
MumbleServer::MurmurException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::MurmurException";
    return typeId;
}

MumbleServer::InvalidSessionException::~InvalidSessionException()
{
}

const ::std::string&
MumbleServer::InvalidSessionException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidSessionException";
    return typeId;
}

MumbleServer::InvalidChannelException::~InvalidChannelException()
{
}

const ::std::string&
MumbleServer::InvalidChannelException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidChannelException";
    return typeId;
}

MumbleServer::InvalidServerException::~InvalidServerException()
{
}

const ::std::string&
MumbleServer::InvalidServerException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidServerException";
    return typeId;
}

MumbleServer::ServerBootedException::~ServerBootedException()
{
}

const ::std::string&
MumbleServer::ServerBootedException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerBootedException";
    return typeId;
}

MumbleServer::ServerFailureException::~ServerFailureException()
{
}

const ::std::string&
MumbleServer::ServerFailureException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerFailureException";
    return typeId;
}

MumbleServer::InvalidUserException::~InvalidUserException()
{
}

const ::std::string&
MumbleServer::InvalidUserException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidUserException";
    return typeId;
}

MumbleServer::InvalidTextureException::~InvalidTextureException()
{
}

const ::std::string&
MumbleServer::InvalidTextureException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidTextureException";
    return typeId;
}

MumbleServer::InvalidCallbackException::~InvalidCallbackException()
{
}

const ::std::string&
MumbleServer::InvalidCallbackException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidCallbackException";
    return typeId;
}

MumbleServer::InvalidSecretException::~InvalidSecretException()
{
}

const ::std::string&
MumbleServer::InvalidSecretException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidSecretException";
    return typeId;
}

MumbleServer::NestingLimitException::~NestingLimitException()
{
}

const ::std::string&
MumbleServer::NestingLimitException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::NestingLimitException";
    return typeId;
}

MumbleServer::WriteOnlyException::~WriteOnlyException()
{
}

const ::std::string&
MumbleServer::WriteOnlyException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::WriteOnlyException";
    return typeId;
}

MumbleServer::InvalidInputDataException::~InvalidInputDataException()
{
}

const ::std::string&
MumbleServer::InvalidInputDataException::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::InvalidInputDataException";
    return typeId;
}

bool
MumbleServer::ServerCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerCallback_ids, iceC_MumbleServer_ServerCallback_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::ServerCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_ServerCallback_ids[0], &iceC_MumbleServer_ServerCallback_ids[2]);
}

::std::string
MumbleServer::ServerCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerCallback::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerCallback";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userConnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userConnected(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userDisconnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userDisconnected(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->userStateChanged(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userTextMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    TextMessage iceP_message;
    istr->readAll(iceP_state, iceP_message);
    inS.endReadParams();
    this->userTextMessage(::std::move(iceP_state), ::std::move(iceP_message), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelCreated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelCreated(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelRemoved(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    this->channelStateChanged(::std::move(iceP_state), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerCallback_ops, iceC_MumbleServer_ServerCallback_ops + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerCallback_ops)
    {
        case 0:
        {
            return _iceD_channelCreated(in, current);
        }
        case 1:
        {
            return _iceD_channelRemoved(in, current);
        }
        case 2:
        {
            return _iceD_channelStateChanged(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_userConnected(in, current);
        }
        case 8:
        {
            return _iceD_userDisconnected(in, current);
        }
        case 9:
        {
            return _iceD_userStateChanged(in, current);
        }
        case 10:
        {
            return _iceD_userTextMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::ServerContextCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerContextCallback_ids, iceC_MumbleServer_ServerContextCallback_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::ServerContextCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_ServerContextCallback_ids[0], &iceC_MumbleServer_ServerContextCallback_ids[2]);
}

::std::string
MumbleServer::ServerContextCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerContextCallback::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerContextCallback";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::ServerContextCallback::_iceD_contextAction(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_action;
    User iceP_usr;
    int iceP_session;
    int iceP_channelid;
    istr->readAll(iceP_action, iceP_usr, iceP_session, iceP_channelid);
    inS.endReadParams();
    this->contextAction(::std::move(iceP_action), ::std::move(iceP_usr), iceP_session, iceP_channelid, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerContextCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerContextCallback_ops, iceC_MumbleServer_ServerContextCallback_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerContextCallback_ops)
    {
        case 0:
        {
            return _iceD_contextAction(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::ServerAuthenticator::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerAuthenticator_ids, iceC_MumbleServer_ServerAuthenticator_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::ServerAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_ServerAuthenticator_ids[0], &iceC_MumbleServer_ServerAuthenticator_ids[2]);
}

::std::string
MumbleServer::ServerAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerAuthenticator::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerAuthenticator";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_authenticate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    CertificateList iceP_certificates;
    ::std::string iceP_certhash;
    bool iceP_certstrong;
    istr->readAll(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong);
    inS.endReadParams();
    ::std::string iceP_newname;
    GroupNameList iceP_groups;
    int ret = this->authenticate(::std::move(iceP_name), ::std::move(iceP_pw), ::std::move(iceP_certificates), ::std::move(iceP_certhash), iceP_certstrong, iceP_newname, iceP_groups, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_newname, iceP_groups, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_getInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    UserInfoMap iceP_info;
    bool ret = this->getInfo(iceP_id, iceP_info, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_info, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_nameToId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    int ret = this->nameToId(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_idToName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::string ret = this->idToName(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_idToTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    Texture ret = this->idToTexture(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerAuthenticator_ops, iceC_MumbleServer_ServerAuthenticator_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerAuthenticator_ops)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_idToName(in, current);
        }
        case 7:
        {
            return _iceD_idToTexture(in, current);
        }
        case 8:
        {
            return _iceD_nameToId(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::ServerUpdatingAuthenticator::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerUpdatingAuthenticator_ids, iceC_MumbleServer_ServerUpdatingAuthenticator_ids + 3, s);
}

::std::vector<::std::string>
MumbleServer::ServerUpdatingAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_ServerUpdatingAuthenticator_ids[0], &iceC_MumbleServer_ServerUpdatingAuthenticator_ids[3]);
}

::std::string
MumbleServer::ServerUpdatingAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerUpdatingAuthenticator::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::ServerUpdatingAuthenticator";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    int ret = this->registerUser(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    int ret = this->unregisterUser(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->readAll(iceP_filter);
    inS.endReadParams();
    NameMap ret = this->getRegisteredUsers(::std::move(iceP_filter), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    UserInfoMap iceP_info;
    istr->readAll(iceP_id, iceP_info);
    inS.endReadParams();
    int ret = this->setInfo(iceP_id, ::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    Texture iceP_tex;
    istr->readAll(iceP_id, iceP_tex);
    inS.endReadParams();
    int ret = this->setTexture(iceP_id, ::std::move(iceP_tex), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerUpdatingAuthenticator_ops, iceC_MumbleServer_ServerUpdatingAuthenticator_ops + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerUpdatingAuthenticator_ops)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_idToName(in, current);
        }
        case 8:
        {
            return _iceD_idToTexture(in, current);
        }
        case 9:
        {
            return _iceD_nameToId(in, current);
        }
        case 10:
        {
            return _iceD_registerUser(in, current);
        }
        case 11:
        {
            return _iceD_setInfo(in, current);
        }
        case 12:
        {
            return _iceD_setTexture(in, current);
        }
        case 13:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::Server::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_Server_ids, iceC_MumbleServer_Server_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_Server_ids[0], &iceC_MumbleServer_Server_ids[2]);
}

::std::string
MumbleServer::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::Server::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::Server";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_isRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->isRunningAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_start(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_stop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_delete(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->deleteAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_id(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->idAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setAuthenticator(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerAuthenticatorPrx> iceP_auth;
    istr->readAll(iceP_auth);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setAuthenticatorAsync(::std::move(iceP_auth), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->readAll(iceP_key);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::string& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getConfAsync(::std::move(iceP_key), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getAllConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ConfigMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getAllConfAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->readAll(iceP_key, iceP_value);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setConfAsync(::std::move(iceP_key), ::std::move(iceP_value), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setSuperuserPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_pw;
    istr->readAll(iceP_pw);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setSuperuserPasswordAsync(::std::move(iceP_pw), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_first;
    int iceP_last;
    istr->readAll(iceP_first, iceP_last);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LogList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getLogAsync(iceP_first, iceP_last, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getLogLen(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getLogLenAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const UserMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUsersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ChannelMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getChannelsAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getCertificateList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    istr->readAll(iceP_session);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CertificateList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getCertificateListAsync(iceP_session, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getTree(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Tree>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->getTreeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BanList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getBansAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    BanList iceP_bans;
    istr->readAll(iceP_bans);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setBansAsync(::std::move(iceP_bans), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_kickUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_reason;
    istr->readAll(iceP_session, iceP_reason);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->kickUserAsync(iceP_session, ::std::move(iceP_reason), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    istr->readAll(iceP_session);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const User& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getStateAsync(iceP_session, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    User iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setStateAsync(::std::move(iceP_state), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_text;
    istr->readAll(iceP_session, iceP_text);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendMessageAsync(iceP_session, ::std::move(iceP_text), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_hasPermission(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    int iceP_channelid;
    int iceP_perm;
    istr->readAll(iceP_session, iceP_channelid, iceP_perm);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->hasPermissionAsync(iceP_session, iceP_channelid, iceP_perm, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_effectivePermissions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    int iceP_channelid;
    istr->readAll(iceP_session, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->effectivePermissionsAsync(iceP_session, iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_action;
    ::std::string iceP_text;
    ::std::shared_ptr<ServerContextCallbackPrx> iceP_cb;
    int iceP_ctx;
    istr->readAll(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addContextCallbackAsync(iceP_session, ::std::move(iceP_action), ::std::move(iceP_text), ::std::move(iceP_cb), iceP_ctx, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerContextCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeContextCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Channel& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getChannelStateAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    Channel iceP_state;
    istr->readAll(iceP_state);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setChannelStateAsync(::std::move(iceP_state), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeChannelAsync(iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_parent;
    istr->readAll(iceP_name, iceP_parent);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->addChannelAsync(::std::move(iceP_name), iceP_parent, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendMessageChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    bool iceP_tree;
    ::std::string iceP_text;
    istr->readAll(iceP_channelid, iceP_tree, iceP_text);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendMessageChannelAsync(iceP_channelid, iceP_tree, ::std::move(iceP_text), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ACLList& iceP_acls, const GroupList& iceP_groups, bool iceP_inherit)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_acls, iceP_groups, iceP_inherit);
        inA->endWriteParams();
        inA->completed();
    };
    this->getACLAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    ACLList iceP_acls;
    GroupList iceP_groups;
    bool iceP_inherit;
    istr->readAll(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setACLAsync(iceP_channelid, ::std::move(iceP_acls), ::std::move(iceP_groups), iceP_inherit, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addUserToGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_session;
    ::std::string iceP_group;
    istr->readAll(iceP_channelid, iceP_session, iceP_group);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addUserToGroupAsync(iceP_channelid, iceP_session, ::std::move(iceP_group), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeUserFromGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_session;
    ::std::string iceP_group;
    istr->readAll(iceP_channelid, iceP_session, iceP_group);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeUserFromGroupAsync(iceP_channelid, iceP_session, ::std::move(iceP_group), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_redirectWhisperGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_session;
    ::std::string iceP_source;
    ::std::string iceP_target;
    istr->readAll(iceP_session, iceP_source, iceP_target);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->redirectWhisperGroupAsync(iceP_session, ::std::move(iceP_source), ::std::move(iceP_target), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUserNames(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    IdList iceP_ids;
    istr->readAll(iceP_ids);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const NameMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUserNamesAsync(::std::move(iceP_ids), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUserIds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    NameList iceP_names;
    istr->readAll(iceP_names);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IdMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUserIdsAsync(::std::move(iceP_names), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->registerUserAsync(::std::move(iceP_info), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->unregisterUserAsync(iceP_userid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_updateRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    UserInfoMap iceP_info;
    istr->readAll(iceP_userid, iceP_info);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->updateRegistrationAsync(iceP_userid, ::std::move(iceP_info), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const UserInfoMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getRegistrationAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->readAll(iceP_filter);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const NameMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getRegisteredUsersAsync(::std::move(iceP_filter), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_verifyPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    istr->readAll(iceP_name, iceP_pw);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->verifyPasswordAsync(::std::move(iceP_name), ::std::move(iceP_pw), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Texture& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getTextureAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    Texture iceP_tex;
    istr->readAll(iceP_userid, iceP_tex);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setTextureAsync(iceP_userid, ::std::move(iceP_tex), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUptimeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_updateCertificate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_certificate;
    ::std::string iceP_privateKey;
    ::std::string iceP_passphrase;
    istr->readAll(iceP_certificate, iceP_privateKey, iceP_passphrase);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->updateCertificateAsync(::std::move(iceP_certificate), ::std::move(iceP_privateKey), ::std::move(iceP_passphrase), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_startListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startListeningAsync(iceP_userid, iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_stopListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopListeningAsync(iceP_userid, iceP_channelid, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_isListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    int iceP_channelid;
    istr->readAll(iceP_userid, iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](bool ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->isListeningAsync(iceP_userid, iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListeningChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_userid;
    istr->readAll(iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getListeningChannelsAsync(iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListeningUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    istr->readAll(iceP_channelid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getListeningUsersAsync(iceP_channelid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListenerVolumeAdjustment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_userid;
    istr->readAll(iceP_channelid, iceP_userid);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](float ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getListenerVolumeAdjustmentAsync(iceP_channelid, iceP_userid, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setListenerVolumeAdjustment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_channelid;
    int iceP_userid;
    float iceP_volumeAdjustment;
    istr->readAll(iceP_channelid, iceP_userid, iceP_volumeAdjustment);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->setListenerVolumeAdjustmentAsync(iceP_channelid, iceP_userid, iceP_volumeAdjustment, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendWelcomeMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    IdList iceP_receiverUserIDs;
    istr->readAll(iceP_receiverUserIDs);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->sendWelcomeMessageAsync(::std::move(iceP_receiverUserIDs), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_Server_ops, iceC_MumbleServer_Server_ops + 62, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_Server_ops)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_addChannel(in, current);
        }
        case 2:
        {
            return _iceD_addContextCallback(in, current);
        }
        case 3:
        {
            return _iceD_addUserToGroup(in, current);
        }
        case 4:
        {
            return _iceD_delete(in, current);
        }
        case 5:
        {
            return _iceD_effectivePermissions(in, current);
        }
        case 6:
        {
            return _iceD_getACL(in, current);
        }
        case 7:
        {
            return _iceD_getAllConf(in, current);
        }
        case 8:
        {
            return _iceD_getBans(in, current);
        }
        case 9:
        {
            return _iceD_getCertificateList(in, current);
        }
        case 10:
        {
            return _iceD_getChannelState(in, current);
        }
        case 11:
        {
            return _iceD_getChannels(in, current);
        }
        case 12:
        {
            return _iceD_getConf(in, current);
        }
        case 13:
        {
            return _iceD_getListenerVolumeAdjustment(in, current);
        }
        case 14:
        {
            return _iceD_getListeningChannels(in, current);
        }
        case 15:
        {
            return _iceD_getListeningUsers(in, current);
        }
        case 16:
        {
            return _iceD_getLog(in, current);
        }
        case 17:
        {
            return _iceD_getLogLen(in, current);
        }
        case 18:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 19:
        {
            return _iceD_getRegistration(in, current);
        }
        case 20:
        {
            return _iceD_getState(in, current);
        }
        case 21:
        {
            return _iceD_getTexture(in, current);
        }
        case 22:
        {
            return _iceD_getTree(in, current);
        }
        case 23:
        {
            return _iceD_getUptime(in, current);
        }
        case 24:
        {
            return _iceD_getUserIds(in, current);
        }
        case 25:
        {
            return _iceD_getUserNames(in, current);
        }
        case 26:
        {
            return _iceD_getUsers(in, current);
        }
        case 27:
        {
            return _iceD_hasPermission(in, current);
        }
        case 28:
        {
            return _iceD_ice_id(in, current);
        }
        case 29:
        {
            return _iceD_ice_ids(in, current);
        }
        case 30:
        {
            return _iceD_ice_isA(in, current);
        }
        case 31:
        {
            return _iceD_ice_ping(in, current);
        }
        case 32:
        {
            return _iceD_id(in, current);
        }
        case 33:
        {
            return _iceD_isListening(in, current);
        }
        case 34:
        {
            return _iceD_isRunning(in, current);
        }
        case 35:
        {
            return _iceD_kickUser(in, current);
        }
        case 36:
        {
            return _iceD_redirectWhisperGroup(in, current);
        }
        case 37:
        {
            return _iceD_registerUser(in, current);
        }
        case 38:
        {
            return _iceD_removeCallback(in, current);
        }
        case 39:
        {
            return _iceD_removeChannel(in, current);
        }
        case 40:
        {
            return _iceD_removeContextCallback(in, current);
        }
        case 41:
        {
            return _iceD_removeUserFromGroup(in, current);
        }
        case 42:
        {
            return _iceD_sendMessage(in, current);
        }
        case 43:
        {
            return _iceD_sendMessageChannel(in, current);
        }
        case 44:
        {
            return _iceD_sendWelcomeMessage(in, current);
        }
        case 45:
        {
            return _iceD_setACL(in, current);
        }
        case 46:
        {
            return _iceD_setAuthenticator(in, current);
        }
        case 47:
        {
            return _iceD_setBans(in, current);
        }
        case 48:
        {
            return _iceD_setChannelState(in, current);
        }
        case 49:
        {
            return _iceD_setConf(in, current);
        }
        case 50:
        {
            return _iceD_setListenerVolumeAdjustment(in, current);
        }
        case 51:
        {
            return _iceD_setState(in, current);
        }
        case 52:
        {
            return _iceD_setSuperuserPassword(in, current);
        }
        case 53:
        {
            return _iceD_setTexture(in, current);
        }
        case 54:
        {
            return _iceD_start(in, current);
        }
        case 55:
        {
            return _iceD_startListening(in, current);
        }
        case 56:
        {
            return _iceD_stop(in, current);
        }
        case 57:
        {
            return _iceD_stopListening(in, current);
        }
        case 58:
        {
            return _iceD_unregisterUser(in, current);
        }
        case 59:
        {
            return _iceD_updateCertificate(in, current);
        }
        case 60:
        {
            return _iceD_updateRegistration(in, current);
        }
        case 61:
        {
            return _iceD_verifyPassword(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::MetaCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_MetaCallback_ids, iceC_MumbleServer_MetaCallback_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::MetaCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_MetaCallback_ids[0], &iceC_MumbleServer_MetaCallback_ids[2]);
}

::std::string
MumbleServer::MetaCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::MetaCallback::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::MetaCallback";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceD_started(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerPrx> iceP_srv;
    istr->readAll(iceP_srv);
    inS.endReadParams();
    this->started(::std::move(iceP_srv), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceD_stopped(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ServerPrx> iceP_srv;
    istr->readAll(iceP_srv);
    inS.endReadParams();
    this->stopped(::std::move(iceP_srv), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_MetaCallback_ops, iceC_MumbleServer_MetaCallback_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_MetaCallback_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_started(in, current);
        }
        case 5:
        {
            return _iceD_stopped(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
MumbleServer::Meta::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_Meta_ids, iceC_MumbleServer_Meta_ids + 2, s);
}

::std::vector<::std::string>
MumbleServer::Meta::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_MumbleServer_Meta_ids[0], &iceC_MumbleServer_Meta_ids[2]);
}

::std::string
MumbleServer::Meta::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::Meta::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::Meta";
    return typeId;
}

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<ServerPrx>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getServerAsync(iceP_id, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_newServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<ServerPrx>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->newServerAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getBootedServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ServerList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getBootedServersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getAllServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ServerList& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getAllServersAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getDefaultConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ConfigMap& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getDefaultConfAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int iceP_major, int iceP_minor, int iceP_patch, const ::std::string& iceP_text)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_major, iceP_minor, iceP_patch, iceP_text);
        inA->endWriteParams();
        inA->completed();
    };
    this->getVersionAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MetaCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->addCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MetaCallbackPrx> iceP_cb;
    istr->readAll(iceP_cb);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->removeCallbackAsync(::std::move(iceP_cb), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getUptimeAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getSlice(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::string& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getSliceAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getSliceChecksums(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Ice::SliceChecksumDict& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->getSliceChecksumsAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_Meta_ops, iceC_MumbleServer_Meta_ops + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_Meta_ops)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_getAllServers(in, current);
        }
        case 2:
        {
            return _iceD_getBootedServers(in, current);
        }
        case 3:
        {
            return _iceD_getDefaultConf(in, current);
        }
        case 4:
        {
            return _iceD_getServer(in, current);
        }
        case 5:
        {
            return _iceD_getSlice(in, current);
        }
        case 6:
        {
            return _iceD_getSliceChecksums(in, current);
        }
        case 7:
        {
            return _iceD_getUptime(in, current);
        }
        case 8:
        {
            return _iceD_getVersion(in, current);
        }
        case 9:
        {
            return _iceD_ice_id(in, current);
        }
        case 10:
        {
            return _iceD_ice_ids(in, current);
        }
        case 11:
        {
            return _iceD_ice_isA(in, current);
        }
        case 12:
        {
            return _iceD_ice_ping(in, current);
        }
        case 13:
        {
            return _iceD_newServer(in, current);
        }
        case 14:
        {
            return _iceD_removeCallback(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

MumbleServer::Tree::~Tree()
{
}

const ::std::string&
MumbleServer::Tree::ice_staticId()
{
    static const ::std::string typeId = "::MumbleServer::Tree";
    return typeId;
}

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_userConnected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_userConnected_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_userDisconnected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_userDisconnected_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_userStateChanged(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_userStateChanged_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_userTextMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const TextMessage& iceP_message, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_userTextMessage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state, iceP_message);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_channelCreated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_channelCreated_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_channelRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_channelRemoved_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerCallbackPrx::_iceI_channelStateChanged(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerCallback_channelStateChanged_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::ServerCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerCallbackPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::ServerCallbackPrx::ice_staticId()
{
    return ServerCallback::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::ServerContextCallbackPrx::_iceI_contextAction(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_action, const User& iceP_usr, int iceP_session, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_ServerContextCallback_contextAction_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_action, iceP_usr, iceP_session, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::ServerContextCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerContextCallbackPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::ServerContextCallbackPrx::ice_staticId()
{
    return ServerContextCallback::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::ServerAuthenticatorPrx::_iceI_authenticate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAuthenticator::AuthenticateResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_pw, const CertificateList& iceP_certificates, const ::std::string& iceP_certhash, bool iceP_certstrong, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_authenticate_name);
    outAsync->invoke(iceC_MumbleServer_ServerAuthenticator_authenticate_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ServerAuthenticator::AuthenticateResult v;
            istr->readAll(v.newname, v.groups, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerAuthenticatorPrx::_iceI_getInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAuthenticator::GetInfoResult>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_getInfo_name);
    outAsync->invoke(iceC_MumbleServer_ServerAuthenticator_getInfo_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ServerAuthenticator::GetInfoResult v;
            istr->readAll(v.info, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerAuthenticatorPrx::_iceI_nameToId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_nameToId_name);
    outAsync->invoke(iceC_MumbleServer_ServerAuthenticator_nameToId_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerAuthenticatorPrx::_iceI_idToName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_idToName_name);
    outAsync->invoke(iceC_MumbleServer_ServerAuthenticator_idToName_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerAuthenticatorPrx::_iceI_idToTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::Texture>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_idToTexture_name);
    outAsync->invoke(iceC_MumbleServer_ServerAuthenticator_idToTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::ServerAuthenticatorPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerAuthenticatorPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::ServerAuthenticatorPrx::ice_staticId()
{
    return ServerAuthenticator::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::ServerUpdatingAuthenticatorPrx::_iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name);
    outAsync->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerUpdatingAuthenticatorPrx::_iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name);
    outAsync->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerUpdatingAuthenticatorPrx::_iceI_getRegisteredUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::NameMap>>& outAsync, const ::std::string& iceP_filter, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    outAsync->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_filter);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerUpdatingAuthenticatorPrx::_iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name);
    outAsync->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerUpdatingAuthenticatorPrx::_iceI_setTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_id, const Texture& iceP_tex, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name);
    outAsync->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_tex);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::ServerUpdatingAuthenticatorPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerUpdatingAuthenticatorPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::ServerUpdatingAuthenticatorPrx::ice_staticId()
{
    return ServerUpdatingAuthenticator::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_isRunning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_isRunning_name);
    outAsync->invoke(iceC_MumbleServer_Server_isRunning_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_start(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_start_name);
    outAsync->invoke(iceC_MumbleServer_Server_start_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ServerFailureException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_stop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_stop_name);
    outAsync->invoke(iceC_MumbleServer_Server_stop_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_delete(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_delete_name);
    outAsync->invoke(iceC_MumbleServer_Server_delete_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_id(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_id_name);
    outAsync->invoke(iceC_MumbleServer_Server_id_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_addCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addCallback_name);
    outAsync->invoke(iceC_MumbleServer_Server_addCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_removeCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeCallback_name);
    outAsync->invoke(iceC_MumbleServer_Server_removeCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setAuthenticator(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerAuthenticatorPrx>& iceP_auth, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setAuthenticator_name);
    outAsync->invoke(iceC_MumbleServer_Server_setAuthenticator_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_auth);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::std::string& iceP_key, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getConf_name);
    outAsync->invoke(iceC_MumbleServer_Server_getConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const WriteOnlyException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getAllConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::ConfigMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getAllConf_name);
    outAsync->invoke(iceC_MumbleServer_Server_getAllConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setConf_name);
    outAsync->invoke(iceC_MumbleServer_Server_setConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key, iceP_value);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setSuperuserPassword(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_pw, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setSuperuserPassword_name);
    outAsync->invoke(iceC_MumbleServer_Server_setSuperuserPassword_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pw);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::LogList>>& outAsync, int iceP_first, int iceP_last, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getLog_name);
    outAsync->invoke(iceC_MumbleServer_Server_getLog_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_first, iceP_last);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getLogLen(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getLogLen_name);
    outAsync->invoke(iceC_MumbleServer_Server_getLogLen_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::UserMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUsers_name);
    outAsync->invoke(iceC_MumbleServer_Server_getUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getChannels(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::ChannelMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getChannels_name);
    outAsync->invoke(iceC_MumbleServer_Server_getChannels_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getCertificateList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::CertificateList>>& outAsync, int iceP_session, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getCertificateList_name);
    outAsync->invoke(iceC_MumbleServer_Server_getCertificateList_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getTree(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::MumbleServer::Tree>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getTree_name);
    outAsync->invoke(iceC_MumbleServer_Server_getTree_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Tree> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getBans(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::BanList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getBans_name);
    outAsync->invoke(iceC_MumbleServer_Server_getBans_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setBans(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const BanList& iceP_bans, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setBans_name);
    outAsync->invoke(iceC_MumbleServer_Server_setBans_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bans);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_kickUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_reason, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_kickUser_name);
    outAsync->invoke(iceC_MumbleServer_Server_kickUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_reason);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::User>>& outAsync, int iceP_session, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getState_name);
    outAsync->invoke(iceC_MumbleServer_Server_getState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const User& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setState_name);
    outAsync->invoke(iceC_MumbleServer_Server_setState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_sendMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_text, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_sendMessage_name);
    outAsync->invoke(iceC_MumbleServer_Server_sendMessage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_text);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_hasPermission(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, int iceP_session, int iceP_channelid, int iceP_perm, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_hasPermission_name);
    outAsync->invoke(iceC_MumbleServer_Server_hasPermission_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_channelid, iceP_perm);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_effectivePermissions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_session, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_effectivePermissions_name);
    outAsync->invoke(iceC_MumbleServer_Server_effectivePermissions_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_addContextCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_action, const ::std::string& iceP_text, const ::std::shared_ptr<ServerContextCallbackPrx>& iceP_cb, int iceP_ctx, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addContextCallback_name);
    outAsync->invoke(iceC_MumbleServer_Server_addContextCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_removeContextCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerContextCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeContextCallback_name);
    outAsync->invoke(iceC_MumbleServer_Server_removeContextCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getChannelState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::Channel>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getChannelState_name);
    outAsync->invoke(iceC_MumbleServer_Server_getChannelState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setChannelState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const Channel& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setChannelState_name);
    outAsync->invoke(iceC_MumbleServer_Server_setChannelState_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_state);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const NestingLimitException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_removeChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeChannel_name);
    outAsync->invoke(iceC_MumbleServer_Server_removeChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_addChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, int iceP_parent, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addChannel_name);
    outAsync->invoke(iceC_MumbleServer_Server_addChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_parent);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const NestingLimitException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_sendMessageChannel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, bool iceP_tree, const ::std::string& iceP_text, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_sendMessageChannel_name);
    outAsync->invoke(iceC_MumbleServer_Server_sendMessageChannel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_tree, iceP_text);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getACL(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Server::GetACLResult>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getACL_name);
    outAsync->invoke(iceC_MumbleServer_Server_getACL_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Server::GetACLResult v;
            istr->readAll(v.acls, v.groups, v.inherit);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setACL(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, const ACLList& iceP_acls, const GroupList& iceP_groups, bool iceP_inherit, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setACL_name);
    outAsync->invoke(iceC_MumbleServer_Server_setACL_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_acls, iceP_groups, iceP_inherit);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_addUserToGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addUserToGroup_name);
    outAsync->invoke(iceC_MumbleServer_Server_addUserToGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_session, iceP_group);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_removeUserFromGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeUserFromGroup_name);
    outAsync->invoke(iceC_MumbleServer_Server_removeUserFromGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_session, iceP_group);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidChannelException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_redirectWhisperGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_session, const ::std::string& iceP_source, const ::std::string& iceP_target, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_redirectWhisperGroup_name);
    outAsync->invoke(iceC_MumbleServer_Server_redirectWhisperGroup_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_session, iceP_source, iceP_target);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidSessionException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getUserNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::NameMap>>& outAsync, const IdList& iceP_ids, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUserNames_name);
    outAsync->invoke(iceC_MumbleServer_Server_getUserNames_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_ids);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getUserIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::IdMap>>& outAsync, const NameList& iceP_names, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUserIds_name);
    outAsync->invoke(iceC_MumbleServer_Server_getUserIds_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_names);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_registerUser_name);
    outAsync->invoke(iceC_MumbleServer_Server_registerUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_unregisterUser_name);
    outAsync->invoke(iceC_MumbleServer_Server_unregisterUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_updateRegistration(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const UserInfoMap& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_updateRegistration_name);
    outAsync->invoke(iceC_MumbleServer_Server_updateRegistration_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_info);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getRegistration(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::UserInfoMap>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getRegistration_name);
    outAsync->invoke(iceC_MumbleServer_Server_getRegistration_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getRegisteredUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::NameMap>>& outAsync, const ::std::string& iceP_filter, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getRegisteredUsers_name);
    outAsync->invoke(iceC_MumbleServer_Server_getRegisteredUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_filter);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_verifyPassword(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_verifyPassword_name);
    outAsync->invoke(iceC_MumbleServer_Server_verifyPassword_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_pw);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::Texture>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getTexture_name);
    outAsync->invoke(iceC_MumbleServer_Server_getTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setTexture(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, const Texture& iceP_tex, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setTexture_name);
    outAsync->invoke(iceC_MumbleServer_Server_setTexture_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_tex);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const InvalidTextureException&)
            {
                throw;
            }
            catch(const InvalidUserException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getUptime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUptime_name);
    outAsync->invoke(iceC_MumbleServer_Server_getUptime_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_updateCertificate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_certificate, const ::std::string& iceP_privateKey, const ::std::string& iceP_passphrase, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_updateCertificate_name);
    outAsync->invoke(iceC_MumbleServer_Server_updateCertificate_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_certificate, iceP_privateKey, iceP_passphrase);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidInputDataException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ServerBootedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_startListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_Server_startListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_stopListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_Server_stopListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_isListening(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, int iceP_userid, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_isListening_name);
    outAsync->invoke(iceC_MumbleServer_Server_isListening_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid, iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getListeningChannels(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::IntList>>& outAsync, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListeningChannels_name);
    outAsync->invoke(iceC_MumbleServer_Server_getListeningChannels_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getListeningUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::IntList>>& outAsync, int iceP_channelid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListeningUsers_name);
    outAsync->invoke(iceC_MumbleServer_Server_getListeningUsers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_getListenerVolumeAdjustment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>& outAsync, int iceP_channelid, int iceP_userid, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListenerVolumeAdjustment_name);
    outAsync->invoke(iceC_MumbleServer_Server_getListenerVolumeAdjustment_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_userid);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_setListenerVolumeAdjustment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_channelid, int iceP_userid, float iceP_volumeAdjustment, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_Server_setListenerVolumeAdjustment_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_channelid, iceP_userid, iceP_volumeAdjustment);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::ServerPrx::_iceI_sendWelcomeMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const IdList& iceP_receiverUserIDs, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_Server_sendWelcomeMessage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_receiverUserIDs);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::ServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::ServerPrx::ice_staticId()
{
    return Server::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::MetaCallbackPrx::_iceI_started(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerPrx>& iceP_srv, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_MetaCallback_started_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_srv);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaCallbackPrx::_iceI_stopped(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ServerPrx>& iceP_srv, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_MumbleServer_MetaCallback_stopped_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_srv);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::MetaCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MetaCallbackPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::MetaCallbackPrx::ice_staticId()
{
    return MetaCallback::ice_staticId();
}

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::MumbleServer::ServerPrx>>>& outAsync, int iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getServer_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getServer_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_newServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::MumbleServer::ServerPrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_newServer_name);
    outAsync->invoke(iceC_MumbleServer_Meta_newServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getBootedServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::ServerList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getBootedServers_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getBootedServers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getAllServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::ServerList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getAllServers_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getAllServers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getDefaultConf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MumbleServer::ConfigMap>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getDefaultConf_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getDefaultConf_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Meta::GetVersionResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getVersion_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getVersion_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Meta::GetVersionResult v;
            istr->readAll(v.major, v.minor, v.patch, v.text);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_addCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<MetaCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_addCallback_name);
    outAsync->invoke(iceC_MumbleServer_Meta_addCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_removeCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<MetaCallbackPrx>& iceP_cb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_removeCallback_name);
    outAsync->invoke(iceC_MumbleServer_Meta_removeCallback_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cb);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const InvalidCallbackException&)
            {
                throw;
            }
            catch(const InvalidSecretException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getUptime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getUptime_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getUptime_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getSlice(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getSlice_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getSlice_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::MetaPrx::_iceI_getSliceChecksums(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::SliceChecksumDict>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getSliceChecksums_name);
    outAsync->invoke(iceC_MumbleServer_Meta_getSliceChecksums_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
MumbleServer::MetaPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MetaPrx>();
}
/// \endcond

const ::std::string&
MumbleServer::MetaPrx::ice_staticId()
{
    return Meta::ice_staticId();
}

namespace Ice
{
}

namespace
{

const char* iceSliceChecksums[] =
{
    "::MumbleServer::ACL", "157797fb27cda83faec7e5374284e275",
    "::MumbleServer::ACLList", "11e99d3da9c9a3cacf599b1045d88370",
    "::MumbleServer::Ban", "a5a9cd583bc04dcdca89bff31e2e1294",
    "::MumbleServer::BanList", "e94e7a8b59e24ccc5ee2fbd41753a2a7",
    "::MumbleServer::CertificateDer", "bda5350e8ec40eef1cae7c2b3c616cf",
    "::MumbleServer::CertificateList", "9626e55ba4d813d9374b686dfb315e",
    "::MumbleServer::Channel", "e7ae81e73bbf7fb4a575d8eedca8458",
    "::MumbleServer::ChannelInfo", "1e1c915adb3475dd6aa6943aff139d7c",
    "::MumbleServer::ChannelList", "a4e0625082768612d43fc41563533c8b",
    "::MumbleServer::ChannelMap", "78fcab14097578194791985595a084",
    "::MumbleServer::ConfigMap", "a959102c70f61ff099b044a145ba2a",
    "::MumbleServer::ContextChannel", "d031ddb65dbaea316b6718ffa867852",
    "::MumbleServer::ContextServer", "36637f606caa3dfe7a88816f3d1d4b4",
    "::MumbleServer::ContextUser", "928e6ca841dc5467d671cc7e94a47b1",
    "::MumbleServer::Group", "4f30a28dc2571d11a4361e55d2bf5923",
    "::MumbleServer::GroupList", "f3b3fa68671f8411d9bd34524ffc153b",
    "::MumbleServer::GroupNameList", "3129349326861d482a77548514a44ea9",
    "::MumbleServer::IdList", "ee9f8c35179c12487ff62e359b7f267b",
    "::MumbleServer::IdMap", "36f07840567acf5a1a182b80cc4ec4c8",
    "::MumbleServer::IntList", "6f1c32278d7993b8e7fcab62838cfa6",
    "::MumbleServer::InvalidCallbackException", "278bf6bd2dd1e7e5dcbdc482c82bbe35",
    "::MumbleServer::InvalidChannelException", "dba473da2b7247f2ae1b2fab0993848",
    "::MumbleServer::InvalidInputDataException", "9e862d16b7a2e897ae8ce8c98a5081a1",
    "::MumbleServer::InvalidSecretException", "c570ebf17f803b19dbb5b2a9b7e147",
    "::MumbleServer::InvalidServerException", "9a9fdd40ba92e699df60753cda58a9",
    "::MumbleServer::InvalidSessionException", "433b17dcfda4e2f75b56966443c88f64",
    "::MumbleServer::InvalidTextureException", "5ade1dd53f39a22f6c2262f3716570",
    "::MumbleServer::InvalidUserException", "37b9da856944847678f0f9c76ce5b9df",
    "::MumbleServer::LogEntry", "baf7375450f0cf5a4221ac1080297efb",
    "::MumbleServer::LogList", "72dc8f688160bad9a94a44522b7b6191",
    "::MumbleServer::Meta", "f928871061a49894ed76a5e9afd8b3c2",
    "::MumbleServer::MetaCallback", "3b7339506c31bda4cbeb7970f6fbdce",
    "::MumbleServer::MurmurException", "f14e757fac3ec91e3eb581beaf8d1af",
    "::MumbleServer::NameList", "492b93e2b12d2bd7f61f719a67b8623b",
    "::MumbleServer::NameMap", "8eb7985198a0add716b9462cbdd8c",
    "::MumbleServer::NestingLimitException", "b11ded4184541bbefce6e879b151638f",
    "::MumbleServer::NetAddress", "fe2a565d478baf1e5e2168ca4492d9d",
    "::MumbleServer::PermissionBan", "ac198d670d743c882937073eae3247",
    "::MumbleServer::PermissionEnter", "54fa28c949285c187f4df657b087b8",
    "::MumbleServer::PermissionKick", "15a8e0bcd0862dba4b5b72550f09aad",
    "::MumbleServer::PermissionLinkChannel", "992d2978f5eb8c5c5c8ec68aee4f890",
    "::MumbleServer::PermissionMakeChannel", "7cb412acce465d84c9a11bc5cd43e66",
    "::MumbleServer::PermissionMakeTempChannel", "beeec37912c744f855149ab30608344",
    "::MumbleServer::PermissionMove", "19f25e8a3ccabbbdf7316a675d6cc87",
    "::MumbleServer::PermissionMuteDeafen", "53c56b4bd8cf231a4090ef24ed893939",
    "::MumbleServer::PermissionRegister", "d0c4e13de6abc868b79cf01bb7d5c1ad",
    "::MumbleServer::PermissionRegisterSelf", "3a9718827e1cdc13b1fde4a724df8",
    "::MumbleServer::PermissionSpeak", "cfd814f27bac13db9c9a342a0512a4b",
    "::MumbleServer::PermissionTextMessage", "b5d36eeecdffc56a3a72854a1469145b",
    "::MumbleServer::PermissionTraverse", "37f12b9bb96c0d07a7c45e1bfef0fe",
    "::MumbleServer::PermissionWhisper", "dddf47c35e992f8cd868c4321f9bcb",
    "::MumbleServer::PermissionWrite", "a939b87d29f9fff8b2f957b3e4b121c0",
    "::MumbleServer::ResetUserContent", "144ba8653415acdee3d3f946a18058",
    "::MumbleServer::Server", "c859ba8ac35f723da5bf631ca7c5a26",
    "::MumbleServer::ServerAuthenticator", "588e4f7f6c31e7bebbc388b1343b86",
    "::MumbleServer::ServerBootedException", "d5e3e6f31eb8dac43e36186f59f2b1f",
    "::MumbleServer::ServerCallback", "c6925adf5c867863d8b1c11d6cc3",
    "::MumbleServer::ServerContextCallback", "83f3ed9f686d5df914e04a57b570f25d",
    "::MumbleServer::ServerFailureException", "7c885c13625e83a4b7731b48f6dbe2",
    "::MumbleServer::ServerList", "6e7b88da2fd3e5d296178aceca55276",
    "::MumbleServer::ServerUpdatingAuthenticator", "b01649b6e69c085efd0137c4534d87b",
    "::MumbleServer::TextMessage", "7fe11d57e63367253c0ec5692441a",
    "::MumbleServer::Texture", "141dd3bb5aa45668e290153de4e8a23c",
    "::MumbleServer::Tree", "c92169edbf14febef3dd4d11373c086",
    "::MumbleServer::TreeList", "54fb50b83cbdce3a46c86994acf62f",
    "::MumbleServer::User", "74ec7daea8b1c30f74cfaf08bd16b2",
    "::MumbleServer::UserInfo", "3c1a3c8ac61325a80f23f21e5466294",
    "::MumbleServer::UserInfoMap", "4ec636e19df849d64563a9e836e2768",
    "::MumbleServer::UserList", "7274fcc9d23b31dfee87f56848e0ef",
    "::MumbleServer::UserMap", "15db3be62794955cd21261408bb6cbb1",
    "::MumbleServer::WriteOnlyException", "8eb3be3bc10badcfb4cf26136c3fba5",
    0
};
const IceInternal::SliceChecksumInit iceSliceChecksumInit(iceSliceChecksums);

}

#else // C++98 mapping

namespace
{

const ::std::string iceC_MumbleServer_ServerCallback_userConnected_name = "userConnected";

const ::std::string iceC_MumbleServer_ServerCallback_userDisconnected_name = "userDisconnected";

const ::std::string iceC_MumbleServer_ServerCallback_userStateChanged_name = "userStateChanged";

const ::std::string iceC_MumbleServer_ServerCallback_userTextMessage_name = "userTextMessage";

const ::std::string iceC_MumbleServer_ServerCallback_channelCreated_name = "channelCreated";

const ::std::string iceC_MumbleServer_ServerCallback_channelRemoved_name = "channelRemoved";

const ::std::string iceC_MumbleServer_ServerCallback_channelStateChanged_name = "channelStateChanged";

const ::std::string iceC_MumbleServer_ServerContextCallback_contextAction_name = "contextAction";

const ::std::string iceC_MumbleServer_ServerAuthenticator_authenticate_name = "authenticate";

const ::std::string iceC_MumbleServer_ServerAuthenticator_getInfo_name = "getInfo";

const ::std::string iceC_MumbleServer_ServerAuthenticator_nameToId_name = "nameToId";

const ::std::string iceC_MumbleServer_ServerAuthenticator_idToName_name = "idToName";

const ::std::string iceC_MumbleServer_ServerAuthenticator_idToTexture_name = "idToTexture";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name = "registerUser";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name = "unregisterUser";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name = "setInfo";

const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name = "setTexture";

const ::std::string iceC_MumbleServer_Server_isRunning_name = "isRunning";

const ::std::string iceC_MumbleServer_Server_start_name = "start";

const ::std::string iceC_MumbleServer_Server_stop_name = "stop";

const ::std::string iceC_MumbleServer_Server_delete_name = "delete";

const ::std::string iceC_MumbleServer_Server_id_name = "id";

const ::std::string iceC_MumbleServer_Server_addCallback_name = "addCallback";

const ::std::string iceC_MumbleServer_Server_removeCallback_name = "removeCallback";

const ::std::string iceC_MumbleServer_Server_setAuthenticator_name = "setAuthenticator";

const ::std::string iceC_MumbleServer_Server_getConf_name = "getConf";

const ::std::string iceC_MumbleServer_Server_getAllConf_name = "getAllConf";

const ::std::string iceC_MumbleServer_Server_setConf_name = "setConf";

const ::std::string iceC_MumbleServer_Server_setSuperuserPassword_name = "setSuperuserPassword";

const ::std::string iceC_MumbleServer_Server_getLog_name = "getLog";

const ::std::string iceC_MumbleServer_Server_getLogLen_name = "getLogLen";

const ::std::string iceC_MumbleServer_Server_getUsers_name = "getUsers";

const ::std::string iceC_MumbleServer_Server_getChannels_name = "getChannels";

const ::std::string iceC_MumbleServer_Server_getCertificateList_name = "getCertificateList";

const ::std::string iceC_MumbleServer_Server_getTree_name = "getTree";

const ::std::string iceC_MumbleServer_Server_getBans_name = "getBans";

const ::std::string iceC_MumbleServer_Server_setBans_name = "setBans";

const ::std::string iceC_MumbleServer_Server_kickUser_name = "kickUser";

const ::std::string iceC_MumbleServer_Server_getState_name = "getState";

const ::std::string iceC_MumbleServer_Server_setState_name = "setState";

const ::std::string iceC_MumbleServer_Server_sendMessage_name = "sendMessage";

const ::std::string iceC_MumbleServer_Server_hasPermission_name = "hasPermission";

const ::std::string iceC_MumbleServer_Server_effectivePermissions_name = "effectivePermissions";

const ::std::string iceC_MumbleServer_Server_addContextCallback_name = "addContextCallback";

const ::std::string iceC_MumbleServer_Server_removeContextCallback_name = "removeContextCallback";

const ::std::string iceC_MumbleServer_Server_getChannelState_name = "getChannelState";

const ::std::string iceC_MumbleServer_Server_setChannelState_name = "setChannelState";

const ::std::string iceC_MumbleServer_Server_removeChannel_name = "removeChannel";

const ::std::string iceC_MumbleServer_Server_addChannel_name = "addChannel";

const ::std::string iceC_MumbleServer_Server_sendMessageChannel_name = "sendMessageChannel";

const ::std::string iceC_MumbleServer_Server_getACL_name = "getACL";

const ::std::string iceC_MumbleServer_Server_setACL_name = "setACL";

const ::std::string iceC_MumbleServer_Server_addUserToGroup_name = "addUserToGroup";

const ::std::string iceC_MumbleServer_Server_removeUserFromGroup_name = "removeUserFromGroup";

const ::std::string iceC_MumbleServer_Server_redirectWhisperGroup_name = "redirectWhisperGroup";

const ::std::string iceC_MumbleServer_Server_getUserNames_name = "getUserNames";

const ::std::string iceC_MumbleServer_Server_getUserIds_name = "getUserIds";

const ::std::string iceC_MumbleServer_Server_registerUser_name = "registerUser";

const ::std::string iceC_MumbleServer_Server_unregisterUser_name = "unregisterUser";

const ::std::string iceC_MumbleServer_Server_updateRegistration_name = "updateRegistration";

const ::std::string iceC_MumbleServer_Server_getRegistration_name = "getRegistration";

const ::std::string iceC_MumbleServer_Server_getRegisteredUsers_name = "getRegisteredUsers";

const ::std::string iceC_MumbleServer_Server_verifyPassword_name = "verifyPassword";

const ::std::string iceC_MumbleServer_Server_getTexture_name = "getTexture";

const ::std::string iceC_MumbleServer_Server_setTexture_name = "setTexture";

const ::std::string iceC_MumbleServer_Server_getUptime_name = "getUptime";

const ::std::string iceC_MumbleServer_Server_updateCertificate_name = "updateCertificate";

const ::std::string iceC_MumbleServer_Server_startListening_name = "startListening";

const ::std::string iceC_MumbleServer_Server_stopListening_name = "stopListening";

const ::std::string iceC_MumbleServer_Server_isListening_name = "isListening";

const ::std::string iceC_MumbleServer_Server_getListeningChannels_name = "getListeningChannels";

const ::std::string iceC_MumbleServer_Server_getListeningUsers_name = "getListeningUsers";

const ::std::string iceC_MumbleServer_Server_getListenerVolumeAdjustment_name = "getListenerVolumeAdjustment";

const ::std::string iceC_MumbleServer_Server_setListenerVolumeAdjustment_name = "setListenerVolumeAdjustment";

const ::std::string iceC_MumbleServer_Server_sendWelcomeMessage_name = "sendWelcomeMessage";

const ::std::string iceC_MumbleServer_MetaCallback_started_name = "started";

const ::std::string iceC_MumbleServer_MetaCallback_stopped_name = "stopped";

const ::std::string iceC_MumbleServer_Meta_getServer_name = "getServer";

const ::std::string iceC_MumbleServer_Meta_newServer_name = "newServer";

const ::std::string iceC_MumbleServer_Meta_getBootedServers_name = "getBootedServers";

const ::std::string iceC_MumbleServer_Meta_getAllServers_name = "getAllServers";

const ::std::string iceC_MumbleServer_Meta_getDefaultConf_name = "getDefaultConf";

const ::std::string iceC_MumbleServer_Meta_getVersion_name = "getVersion";

const ::std::string iceC_MumbleServer_Meta_addCallback_name = "addCallback";

const ::std::string iceC_MumbleServer_Meta_removeCallback_name = "removeCallback";

const ::std::string iceC_MumbleServer_Meta_getUptime_name = "getUptime";

const ::std::string iceC_MumbleServer_Meta_getSlice_name = "getSlice";

const ::std::string iceC_MumbleServer_Meta_getSliceChecksums_name = "getSliceChecksums";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::MurmurException> iceC_MumbleServer_MurmurException_init("::MumbleServer::MurmurException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::MurmurException::~MurmurException()
{
}
#else
MumbleServer::MurmurException::~MurmurException() throw()
{
}
#endif

::std::string
MumbleServer::MurmurException::ice_id() const
{
    return "::MumbleServer::MurmurException";
}

MumbleServer::MurmurException*
MumbleServer::MurmurException::ice_clone() const
{
    return new MurmurException(*this);
}

void
MumbleServer::MurmurException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::MurmurException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::MurmurException", -1, true);
    ::Ice::StreamWriter< MurmurException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::MurmurException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MurmurException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidSessionException> iceC_MumbleServer_InvalidSessionException_init("::MumbleServer::InvalidSessionException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidSessionException::~InvalidSessionException()
{
}
#else
MumbleServer::InvalidSessionException::~InvalidSessionException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidSessionException::ice_id() const
{
    return "::MumbleServer::InvalidSessionException";
}

MumbleServer::InvalidSessionException*
MumbleServer::InvalidSessionException::ice_clone() const
{
    return new InvalidSessionException(*this);
}

void
MumbleServer::InvalidSessionException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidSessionException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidSessionException", -1, false);
    ::Ice::StreamWriter< InvalidSessionException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidSessionException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidSessionException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidChannelException> iceC_MumbleServer_InvalidChannelException_init("::MumbleServer::InvalidChannelException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidChannelException::~InvalidChannelException()
{
}
#else
MumbleServer::InvalidChannelException::~InvalidChannelException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidChannelException::ice_id() const
{
    return "::MumbleServer::InvalidChannelException";
}

MumbleServer::InvalidChannelException*
MumbleServer::InvalidChannelException::ice_clone() const
{
    return new InvalidChannelException(*this);
}

void
MumbleServer::InvalidChannelException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidChannelException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidChannelException", -1, false);
    ::Ice::StreamWriter< InvalidChannelException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidChannelException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidChannelException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidServerException> iceC_MumbleServer_InvalidServerException_init("::MumbleServer::InvalidServerException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidServerException::~InvalidServerException()
{
}
#else
MumbleServer::InvalidServerException::~InvalidServerException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidServerException::ice_id() const
{
    return "::MumbleServer::InvalidServerException";
}

MumbleServer::InvalidServerException*
MumbleServer::InvalidServerException::ice_clone() const
{
    return new InvalidServerException(*this);
}

void
MumbleServer::InvalidServerException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidServerException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidServerException", -1, false);
    ::Ice::StreamWriter< InvalidServerException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidServerException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidServerException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::ServerBootedException> iceC_MumbleServer_ServerBootedException_init("::MumbleServer::ServerBootedException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::ServerBootedException::~ServerBootedException()
{
}
#else
MumbleServer::ServerBootedException::~ServerBootedException() throw()
{
}
#endif

::std::string
MumbleServer::ServerBootedException::ice_id() const
{
    return "::MumbleServer::ServerBootedException";
}

MumbleServer::ServerBootedException*
MumbleServer::ServerBootedException::ice_clone() const
{
    return new ServerBootedException(*this);
}

void
MumbleServer::ServerBootedException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::ServerBootedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::ServerBootedException", -1, false);
    ::Ice::StreamWriter< ServerBootedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::ServerBootedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerBootedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::ServerFailureException> iceC_MumbleServer_ServerFailureException_init("::MumbleServer::ServerFailureException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::ServerFailureException::~ServerFailureException()
{
}
#else
MumbleServer::ServerFailureException::~ServerFailureException() throw()
{
}
#endif

::std::string
MumbleServer::ServerFailureException::ice_id() const
{
    return "::MumbleServer::ServerFailureException";
}

MumbleServer::ServerFailureException*
MumbleServer::ServerFailureException::ice_clone() const
{
    return new ServerFailureException(*this);
}

void
MumbleServer::ServerFailureException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::ServerFailureException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::ServerFailureException", -1, false);
    ::Ice::StreamWriter< ServerFailureException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::ServerFailureException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerFailureException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidUserException> iceC_MumbleServer_InvalidUserException_init("::MumbleServer::InvalidUserException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidUserException::~InvalidUserException()
{
}
#else
MumbleServer::InvalidUserException::~InvalidUserException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidUserException::ice_id() const
{
    return "::MumbleServer::InvalidUserException";
}

MumbleServer::InvalidUserException*
MumbleServer::InvalidUserException::ice_clone() const
{
    return new InvalidUserException(*this);
}

void
MumbleServer::InvalidUserException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidUserException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidUserException", -1, false);
    ::Ice::StreamWriter< InvalidUserException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidUserException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidUserException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidTextureException> iceC_MumbleServer_InvalidTextureException_init("::MumbleServer::InvalidTextureException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidTextureException::~InvalidTextureException()
{
}
#else
MumbleServer::InvalidTextureException::~InvalidTextureException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidTextureException::ice_id() const
{
    return "::MumbleServer::InvalidTextureException";
}

MumbleServer::InvalidTextureException*
MumbleServer::InvalidTextureException::ice_clone() const
{
    return new InvalidTextureException(*this);
}

void
MumbleServer::InvalidTextureException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidTextureException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidTextureException", -1, false);
    ::Ice::StreamWriter< InvalidTextureException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidTextureException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidTextureException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidCallbackException> iceC_MumbleServer_InvalidCallbackException_init("::MumbleServer::InvalidCallbackException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidCallbackException::~InvalidCallbackException()
{
}
#else
MumbleServer::InvalidCallbackException::~InvalidCallbackException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidCallbackException::ice_id() const
{
    return "::MumbleServer::InvalidCallbackException";
}

MumbleServer::InvalidCallbackException*
MumbleServer::InvalidCallbackException::ice_clone() const
{
    return new InvalidCallbackException(*this);
}

void
MumbleServer::InvalidCallbackException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidCallbackException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidCallbackException", -1, false);
    ::Ice::StreamWriter< InvalidCallbackException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidCallbackException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidCallbackException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidSecretException> iceC_MumbleServer_InvalidSecretException_init("::MumbleServer::InvalidSecretException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidSecretException::~InvalidSecretException()
{
}
#else
MumbleServer::InvalidSecretException::~InvalidSecretException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidSecretException::ice_id() const
{
    return "::MumbleServer::InvalidSecretException";
}

MumbleServer::InvalidSecretException*
MumbleServer::InvalidSecretException::ice_clone() const
{
    return new InvalidSecretException(*this);
}

void
MumbleServer::InvalidSecretException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidSecretException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidSecretException", -1, false);
    ::Ice::StreamWriter< InvalidSecretException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidSecretException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidSecretException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::NestingLimitException> iceC_MumbleServer_NestingLimitException_init("::MumbleServer::NestingLimitException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::NestingLimitException::~NestingLimitException()
{
}
#else
MumbleServer::NestingLimitException::~NestingLimitException() throw()
{
}
#endif

::std::string
MumbleServer::NestingLimitException::ice_id() const
{
    return "::MumbleServer::NestingLimitException";
}

MumbleServer::NestingLimitException*
MumbleServer::NestingLimitException::ice_clone() const
{
    return new NestingLimitException(*this);
}

void
MumbleServer::NestingLimitException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::NestingLimitException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::NestingLimitException", -1, false);
    ::Ice::StreamWriter< NestingLimitException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::NestingLimitException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< NestingLimitException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::WriteOnlyException> iceC_MumbleServer_WriteOnlyException_init("::MumbleServer::WriteOnlyException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::WriteOnlyException::~WriteOnlyException()
{
}
#else
MumbleServer::WriteOnlyException::~WriteOnlyException() throw()
{
}
#endif

::std::string
MumbleServer::WriteOnlyException::ice_id() const
{
    return "::MumbleServer::WriteOnlyException";
}

MumbleServer::WriteOnlyException*
MumbleServer::WriteOnlyException::ice_clone() const
{
    return new WriteOnlyException(*this);
}

void
MumbleServer::WriteOnlyException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::WriteOnlyException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::WriteOnlyException", -1, false);
    ::Ice::StreamWriter< WriteOnlyException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::WriteOnlyException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< WriteOnlyException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::MumbleServer::InvalidInputDataException> iceC_MumbleServer_InvalidInputDataException_init("::MumbleServer::InvalidInputDataException");

}

#ifdef ICE_CPP11_COMPILER
MumbleServer::InvalidInputDataException::~InvalidInputDataException()
{
}
#else
MumbleServer::InvalidInputDataException::~InvalidInputDataException() throw()
{
}
#endif

::std::string
MumbleServer::InvalidInputDataException::ice_id() const
{
    return "::MumbleServer::InvalidInputDataException";
}

MumbleServer::InvalidInputDataException*
MumbleServer::InvalidInputDataException::ice_clone() const
{
    return new InvalidInputDataException(*this);
}

void
MumbleServer::InvalidInputDataException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
MumbleServer::InvalidInputDataException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::MumbleServer::InvalidInputDataException", -1, false);
    ::Ice::StreamWriter< InvalidInputDataException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    MurmurException::_writeImpl(ostr);
}

void
MumbleServer::InvalidInputDataException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< InvalidInputDataException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    MurmurException::_readImpl(istr);
}
/// \endcond

MumbleServer::AMD_Server_isRunning::~AMD_Server_isRunning()
{
}

MumbleServer::AMD_Server_start::~AMD_Server_start()
{
}

MumbleServer::AMD_Server_stop::~AMD_Server_stop()
{
}

MumbleServer::AMD_Server_delete::~AMD_Server_delete()
{
}

MumbleServer::AMD_Server_id::~AMD_Server_id()
{
}

MumbleServer::AMD_Server_addCallback::~AMD_Server_addCallback()
{
}

MumbleServer::AMD_Server_removeCallback::~AMD_Server_removeCallback()
{
}

MumbleServer::AMD_Server_setAuthenticator::~AMD_Server_setAuthenticator()
{
}

MumbleServer::AMD_Server_getConf::~AMD_Server_getConf()
{
}

MumbleServer::AMD_Server_getAllConf::~AMD_Server_getAllConf()
{
}

MumbleServer::AMD_Server_setConf::~AMD_Server_setConf()
{
}

MumbleServer::AMD_Server_setSuperuserPassword::~AMD_Server_setSuperuserPassword()
{
}

MumbleServer::AMD_Server_getLog::~AMD_Server_getLog()
{
}

MumbleServer::AMD_Server_getLogLen::~AMD_Server_getLogLen()
{
}

MumbleServer::AMD_Server_getUsers::~AMD_Server_getUsers()
{
}

MumbleServer::AMD_Server_getChannels::~AMD_Server_getChannels()
{
}

MumbleServer::AMD_Server_getCertificateList::~AMD_Server_getCertificateList()
{
}

MumbleServer::AMD_Server_getTree::~AMD_Server_getTree()
{
}

MumbleServer::AMD_Server_getBans::~AMD_Server_getBans()
{
}

MumbleServer::AMD_Server_setBans::~AMD_Server_setBans()
{
}

MumbleServer::AMD_Server_kickUser::~AMD_Server_kickUser()
{
}

MumbleServer::AMD_Server_getState::~AMD_Server_getState()
{
}

MumbleServer::AMD_Server_setState::~AMD_Server_setState()
{
}

MumbleServer::AMD_Server_sendMessage::~AMD_Server_sendMessage()
{
}

MumbleServer::AMD_Server_hasPermission::~AMD_Server_hasPermission()
{
}

MumbleServer::AMD_Server_effectivePermissions::~AMD_Server_effectivePermissions()
{
}

MumbleServer::AMD_Server_addContextCallback::~AMD_Server_addContextCallback()
{
}

MumbleServer::AMD_Server_removeContextCallback::~AMD_Server_removeContextCallback()
{
}

MumbleServer::AMD_Server_getChannelState::~AMD_Server_getChannelState()
{
}

MumbleServer::AMD_Server_setChannelState::~AMD_Server_setChannelState()
{
}

MumbleServer::AMD_Server_removeChannel::~AMD_Server_removeChannel()
{
}

MumbleServer::AMD_Server_addChannel::~AMD_Server_addChannel()
{
}

MumbleServer::AMD_Server_sendMessageChannel::~AMD_Server_sendMessageChannel()
{
}

MumbleServer::AMD_Server_getACL::~AMD_Server_getACL()
{
}

MumbleServer::AMD_Server_setACL::~AMD_Server_setACL()
{
}

MumbleServer::AMD_Server_addUserToGroup::~AMD_Server_addUserToGroup()
{
}

MumbleServer::AMD_Server_removeUserFromGroup::~AMD_Server_removeUserFromGroup()
{
}

MumbleServer::AMD_Server_redirectWhisperGroup::~AMD_Server_redirectWhisperGroup()
{
}

MumbleServer::AMD_Server_getUserNames::~AMD_Server_getUserNames()
{
}

MumbleServer::AMD_Server_getUserIds::~AMD_Server_getUserIds()
{
}

MumbleServer::AMD_Server_registerUser::~AMD_Server_registerUser()
{
}

MumbleServer::AMD_Server_unregisterUser::~AMD_Server_unregisterUser()
{
}

MumbleServer::AMD_Server_updateRegistration::~AMD_Server_updateRegistration()
{
}

MumbleServer::AMD_Server_getRegistration::~AMD_Server_getRegistration()
{
}

MumbleServer::AMD_Server_getRegisteredUsers::~AMD_Server_getRegisteredUsers()
{
}

MumbleServer::AMD_Server_verifyPassword::~AMD_Server_verifyPassword()
{
}

MumbleServer::AMD_Server_getTexture::~AMD_Server_getTexture()
{
}

MumbleServer::AMD_Server_setTexture::~AMD_Server_setTexture()
{
}

MumbleServer::AMD_Server_getUptime::~AMD_Server_getUptime()
{
}

MumbleServer::AMD_Server_updateCertificate::~AMD_Server_updateCertificate()
{
}

MumbleServer::AMD_Server_startListening::~AMD_Server_startListening()
{
}

MumbleServer::AMD_Server_stopListening::~AMD_Server_stopListening()
{
}

MumbleServer::AMD_Server_isListening::~AMD_Server_isListening()
{
}

MumbleServer::AMD_Server_getListeningChannels::~AMD_Server_getListeningChannels()
{
}

MumbleServer::AMD_Server_getListeningUsers::~AMD_Server_getListeningUsers()
{
}

MumbleServer::AMD_Server_getListenerVolumeAdjustment::~AMD_Server_getListenerVolumeAdjustment()
{
}

MumbleServer::AMD_Server_setListenerVolumeAdjustment::~AMD_Server_setListenerVolumeAdjustment()
{
}

MumbleServer::AMD_Server_sendWelcomeMessage::~AMD_Server_sendWelcomeMessage()
{
}

MumbleServer::AMD_Meta_getServer::~AMD_Meta_getServer()
{
}

MumbleServer::AMD_Meta_newServer::~AMD_Meta_newServer()
{
}

MumbleServer::AMD_Meta_getBootedServers::~AMD_Meta_getBootedServers()
{
}

MumbleServer::AMD_Meta_getAllServers::~AMD_Meta_getAllServers()
{
}

MumbleServer::AMD_Meta_getDefaultConf::~AMD_Meta_getDefaultConf()
{
}

MumbleServer::AMD_Meta_getVersion::~AMD_Meta_getVersion()
{
}

MumbleServer::AMD_Meta_addCallback::~AMD_Meta_addCallback()
{
}

MumbleServer::AMD_Meta_removeCallback::~AMD_Meta_removeCallback()
{
}

MumbleServer::AMD_Meta_getUptime::~AMD_Meta_getUptime()
{
}

MumbleServer::AMD_Meta_getSlice::~AMD_Meta_getSlice()
{
}

MumbleServer::AMD_Meta_getSliceChecksums::~AMD_Meta_getSliceChecksums()
{
}

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_isRunning::AMD_Server_isRunning(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_isRunning::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_start::AMD_Server_start(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_start::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_stop::AMD_Server_stop(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_stop::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_delete::AMD_Server_delete(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_delete::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_id::AMD_Server_id(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_id::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_addCallback::AMD_Server_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_addCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_removeCallback::AMD_Server_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_removeCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setAuthenticator::AMD_Server_setAuthenticator(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setAuthenticator::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getConf::AMD_Server_getConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getConf::ice_response(const ::std::string& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getAllConf::AMD_Server_getAllConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getAllConf::ice_response(const ::MumbleServer::ConfigMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setConf::AMD_Server_setConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setConf::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setSuperuserPassword::AMD_Server_setSuperuserPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setSuperuserPassword::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getLog::AMD_Server_getLog(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getLog::ice_response(const ::MumbleServer::LogList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getLogLen::AMD_Server_getLogLen(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getLogLen::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getUsers::AMD_Server_getUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getUsers::ice_response(const ::MumbleServer::UserMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getChannels::AMD_Server_getChannels(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getChannels::ice_response(const ::MumbleServer::ChannelMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getCertificateList::AMD_Server_getCertificateList(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getCertificateList::ice_response(const ::MumbleServer::CertificateList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getTree::AMD_Server_getTree(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getTree::ice_response(const ::MumbleServer::TreePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getBans::AMD_Server_getBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getBans::ice_response(const ::MumbleServer::BanList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setBans::AMD_Server_setBans(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setBans::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_kickUser::AMD_Server_kickUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_kickUser::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getState::AMD_Server_getState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getState::ice_response(const ::MumbleServer::User& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setState::AMD_Server_setState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setState::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_sendMessage::AMD_Server_sendMessage(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_sendMessage::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_hasPermission::AMD_Server_hasPermission(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_hasPermission::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_effectivePermissions::AMD_Server_effectivePermissions(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_effectivePermissions::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_addContextCallback::AMD_Server_addContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_addContextCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_removeContextCallback::AMD_Server_removeContextCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_removeContextCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getChannelState::AMD_Server_getChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getChannelState::ice_response(const ::MumbleServer::Channel& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setChannelState::AMD_Server_setChannelState(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setChannelState::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_removeChannel::AMD_Server_removeChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_removeChannel::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_addChannel::AMD_Server_addChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_addChannel::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_sendMessageChannel::AMD_Server_sendMessageChannel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_sendMessageChannel::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getACL::AMD_Server_getACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getACL::ice_response(const ::MumbleServer::ACLList& acls, const ::MumbleServer::GroupList& groups, bool inherit)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(acls);
    ostr->write(groups);
    ostr->write(inherit);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setACL::AMD_Server_setACL(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setACL::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_addUserToGroup::AMD_Server_addUserToGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_addUserToGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_removeUserFromGroup::AMD_Server_removeUserFromGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_removeUserFromGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_redirectWhisperGroup::AMD_Server_redirectWhisperGroup(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_redirectWhisperGroup::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getUserNames::AMD_Server_getUserNames(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getUserNames::ice_response(const ::MumbleServer::NameMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getUserIds::AMD_Server_getUserIds(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getUserIds::ice_response(const ::MumbleServer::IdMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_registerUser::AMD_Server_registerUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_registerUser::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_unregisterUser::AMD_Server_unregisterUser(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_unregisterUser::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_updateRegistration::AMD_Server_updateRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_updateRegistration::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getRegistration::AMD_Server_getRegistration(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getRegistration::ice_response(const ::MumbleServer::UserInfoMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getRegisteredUsers::AMD_Server_getRegisteredUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getRegisteredUsers::ice_response(const ::MumbleServer::NameMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_verifyPassword::AMD_Server_verifyPassword(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_verifyPassword::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getTexture::AMD_Server_getTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getTexture::ice_response(const ::MumbleServer::Texture& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setTexture::AMD_Server_setTexture(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setTexture::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getUptime::AMD_Server_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getUptime::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_updateCertificate::AMD_Server_updateCertificate(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_updateCertificate::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_startListening::AMD_Server_startListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_startListening::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_stopListening::AMD_Server_stopListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_stopListening::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_isListening::AMD_Server_isListening(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_isListening::ice_response(bool ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getListeningChannels::AMD_Server_getListeningChannels(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getListeningChannels::ice_response(const ::MumbleServer::IntList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getListeningUsers::AMD_Server_getListeningUsers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getListeningUsers::ice_response(const ::MumbleServer::IntList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_getListenerVolumeAdjustment::AMD_Server_getListenerVolumeAdjustment(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_getListenerVolumeAdjustment::ice_response(::Ice::Float ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_setListenerVolumeAdjustment::AMD_Server_setListenerVolumeAdjustment(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_setListenerVolumeAdjustment::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Server_sendWelcomeMessage::AMD_Server_sendWelcomeMessage(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Server_sendWelcomeMessage::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getServer::AMD_Meta_getServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getServer::ice_response(const ::MumbleServer::ServerPrx& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_newServer::AMD_Meta_newServer(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_newServer::ice_response(const ::MumbleServer::ServerPrx& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getBootedServers::AMD_Meta_getBootedServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getBootedServers::ice_response(const ::MumbleServer::ServerList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getAllServers::AMD_Meta_getAllServers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getAllServers::ice_response(const ::MumbleServer::ServerList& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getDefaultConf::AMD_Meta_getDefaultConf(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getDefaultConf::ice_response(const ::MumbleServer::ConfigMap& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getVersion::AMD_Meta_getVersion(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getVersion::ice_response(::Ice::Int major, ::Ice::Int minor, ::Ice::Int patch, const ::std::string& text)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(major);
    ostr->write(minor);
    ostr->write(patch);
    ostr->write(text);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_addCallback::AMD_Meta_addCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_addCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_removeCallback::AMD_Meta_removeCallback(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_removeCallback::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getUptime::AMD_Meta_getUptime(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getUptime::ice_response(::Ice::Int ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getSlice::AMD_Meta_getSlice(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getSlice::ice_response(const ::std::string& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::MumbleServer::AMD_Meta_getSliceChecksums::AMD_Meta_getSliceChecksums(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::MumbleServer::AMD_Meta_getSliceChecksums::ice_response(const ::Ice::SliceChecksumDict& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(Tree* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Tree>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Tree;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::Tree::_newInstance() const
{
    return new Tree;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::Tree::ice_staticId()
{
    return ::MumbleServer::Tree::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(ServerCallback* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_userConnected(const ::MumbleServer::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_userConnected_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_userConnected_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_userConnected_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_userConnected(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_userConnected_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_userDisconnected(const ::MumbleServer::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_userDisconnected_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_userDisconnected_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_userDisconnected_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_userDisconnected(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_userDisconnected_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_userStateChanged(const ::MumbleServer::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_userStateChanged_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_userStateChanged_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_userStateChanged_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_userStateChanged(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_userStateChanged_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_userTextMessage(const ::MumbleServer::User& iceP_state, const ::MumbleServer::TextMessage& iceP_message, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_userTextMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_userTextMessage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        ostr->write(iceP_message);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_userTextMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_userTextMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_userTextMessage_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_channelCreated(const ::MumbleServer::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_channelCreated_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_channelCreated_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_channelCreated_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_channelCreated(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_channelCreated_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_channelRemoved(const ::MumbleServer::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_channelRemoved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_channelRemoved_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_channelRemoved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_channelRemoved(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_channelRemoved_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerCallback::_iceI_begin_channelStateChanged(const ::MumbleServer::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerCallback_channelStateChanged_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerCallback_channelStateChanged_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerCallback_channelStateChanged_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerCallback::end_channelStateChanged(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerCallback_channelStateChanged_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::ServerCallback::_newInstance() const
{
    return new ServerCallback;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::ServerCallback::ice_staticId()
{
    return ::MumbleServer::ServerCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(ServerContextCallback* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerContextCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerContextCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerContextCallback::_iceI_begin_contextAction(const ::std::string& iceP_action, const ::MumbleServer::User& iceP_usr, ::Ice::Int iceP_session, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerContextCallback_contextAction_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerContextCallback_contextAction_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_action);
        ostr->write(iceP_usr);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerContextCallback_contextAction_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::ServerContextCallback::end_contextAction(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_ServerContextCallback_contextAction_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::ServerContextCallback::_newInstance() const
{
    return new ServerContextCallback;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::ServerContextCallback::ice_staticId()
{
    return ::MumbleServer::ServerContextCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(ServerAuthenticator* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerAuthenticator;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerAuthenticator::_iceI_begin_authenticate(const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::MumbleServer::CertificateList& iceP_certificates, const ::std::string& iceP_certhash, bool iceP_certstrong, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_authenticate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerAuthenticator_authenticate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerAuthenticator_authenticate_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_pw);
        ostr->write(iceP_certificates);
        ostr->write(iceP_certhash);
        ostr->write(iceP_certstrong);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerAuthenticator_authenticate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerAuthenticator::end_authenticate(::std::string& iceP_newname, ::MumbleServer::GroupNameList& iceP_groups, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_authenticate_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_newname);
    istr->read(iceP_groups);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::MumbleServer::ServerAuthenticator::_iceI_end_authenticate(::std::string& iceP_newname, ::MumbleServer::GroupNameList& iceP_groups, ::Ice::Int& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_authenticate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_newname);
    istr->read(iceP_groups);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerAuthenticator::_iceI_begin_getInfo(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_getInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerAuthenticator_getInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerAuthenticator_getInfo_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerAuthenticator_getInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::MumbleServer::ServerAuthenticator::end_getInfo(::MumbleServer::UserInfoMap& iceP_info, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_getInfo_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::MumbleServer::ServerAuthenticator::_iceI_end_getInfo(::MumbleServer::UserInfoMap& iceP_info, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_getInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerAuthenticator::_iceI_begin_nameToId(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_nameToId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerAuthenticator_nameToId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerAuthenticator_nameToId_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerAuthenticator_nameToId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerAuthenticator::end_nameToId(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_nameToId_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerAuthenticator::_iceI_begin_idToName(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_idToName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerAuthenticator_idToName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerAuthenticator_idToName_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerAuthenticator_idToName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::MumbleServer::ServerAuthenticator::end_idToName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_idToName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerAuthenticator::_iceI_begin_idToTexture(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerAuthenticator_idToTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerAuthenticator_idToTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerAuthenticator_idToTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerAuthenticator_idToTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::Texture
IceProxy::MumbleServer::ServerAuthenticator::end_idToTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerAuthenticator_idToTexture_name);
    ::MumbleServer::Texture ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::ServerAuthenticator::_newInstance() const
{
    return new ServerAuthenticator;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::ServerAuthenticator::ice_staticId()
{
    return ::MumbleServer::ServerAuthenticator::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(ServerUpdatingAuthenticator* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ServerUpdatingAuthenticator>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ServerUpdatingAuthenticator;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_iceI_begin_registerUser(const ::MumbleServer::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerUpdatingAuthenticator::end_registerUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerUpdatingAuthenticator_registerUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_iceI_begin_unregisterUser(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerUpdatingAuthenticator::end_unregisterUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerUpdatingAuthenticator_unregisterUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_iceI_begin_getRegisteredUsers(const ::std::string& iceP_filter, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_filter);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::NameMap
IceProxy::MumbleServer::ServerUpdatingAuthenticator::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerUpdatingAuthenticator_getRegisteredUsers_name);
    ::MumbleServer::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_iceI_begin_setInfo(::Ice::Int iceP_id, const ::MumbleServer::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerUpdatingAuthenticator::end_setInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerUpdatingAuthenticator_setInfo_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_iceI_begin_setTexture(::Ice::Int iceP_id, const ::MumbleServer::Texture& iceP_tex, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_tex);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::ServerUpdatingAuthenticator::end_setTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_ServerUpdatingAuthenticator_setTexture_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::ServerUpdatingAuthenticator::_newInstance() const
{
    return new ServerUpdatingAuthenticator;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::ServerUpdatingAuthenticator::ice_staticId()
{
    return ::MumbleServer::ServerUpdatingAuthenticator::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(Server* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Server>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Server;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_isRunning(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_isRunning_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_isRunning_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_isRunning_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_isRunning_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::MumbleServer::Server::end_isRunning(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_isRunning_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_start(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_start_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_start_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_start_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_start_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_start(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_start_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerFailureException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_stop(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_stop_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_stop_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_stop_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_stop_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_stop(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_stop_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_delete(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_delete_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_delete_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_delete_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_delete_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_delete(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_delete_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_id(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_id_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_id_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_id_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_id_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_id(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_id_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_addCallback(const ::MumbleServer::ServerCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_addCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_addCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_addCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_addCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_addCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_removeCallback(const ::MumbleServer::ServerCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_removeCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_removeCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_removeCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_removeCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_removeCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setAuthenticator(const ::MumbleServer::ServerAuthenticatorPrx& iceP_auth, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setAuthenticator_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setAuthenticator_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setAuthenticator_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_auth);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setAuthenticator_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setAuthenticator(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setAuthenticator_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getConf(const ::std::string& iceP_key, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getConf_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::MumbleServer::Server::end_getConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getConf_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::WriteOnlyException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getAllConf(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getAllConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getAllConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getAllConf_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getAllConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ConfigMap
IceProxy::MumbleServer::Server::end_getAllConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getAllConf_name);
    ::MumbleServer::ConfigMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setConf(const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setConf_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        ostr->write(iceP_value);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setConf_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setSuperuserPassword(const ::std::string& iceP_pw, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setSuperuserPassword_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setSuperuserPassword_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setSuperuserPassword_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_pw);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setSuperuserPassword_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setSuperuserPassword(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setSuperuserPassword_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getLog(::Ice::Int iceP_first, ::Ice::Int iceP_last, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getLog_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getLog_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getLog_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_first);
        ostr->write(iceP_last);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getLog_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::LogList
IceProxy::MumbleServer::Server::end_getLog(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getLog_name);
    ::MumbleServer::LogList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getLogLen(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getLogLen_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getLogLen_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getLogLen_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getLogLen_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_getLogLen(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getLogLen_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getUsers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getUsers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::UserMap
IceProxy::MumbleServer::Server::end_getUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getUsers_name);
    ::MumbleServer::UserMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getChannels(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getChannels_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getChannels_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getChannels_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getChannels_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ChannelMap
IceProxy::MumbleServer::Server::end_getChannels(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getChannels_name);
    ::MumbleServer::ChannelMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getCertificateList(::Ice::Int iceP_session, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getCertificateList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getCertificateList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getCertificateList_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getCertificateList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::CertificateList
IceProxy::MumbleServer::Server::end_getCertificateList(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getCertificateList_name);
    ::MumbleServer::CertificateList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getTree(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getTree_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getTree_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getTree_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getTree_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::TreePtr
IceProxy::MumbleServer::Server::end_getTree(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getTree_name);
    ::MumbleServer::TreePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getBans(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getBans_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getBans_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getBans_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getBans_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::BanList
IceProxy::MumbleServer::Server::end_getBans(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getBans_name);
    ::MumbleServer::BanList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setBans(const ::MumbleServer::BanList& iceP_bans, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setBans_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setBans_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setBans_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_bans);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setBans_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setBans(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setBans_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_kickUser(::Ice::Int iceP_session, const ::std::string& iceP_reason, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_kickUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_kickUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_kickUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_reason);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_kickUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_kickUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_kickUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getState(::Ice::Int iceP_session, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::User
IceProxy::MumbleServer::Server::end_getState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getState_name);
    ::MumbleServer::User ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setState(const ::MumbleServer::User& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setState_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_sendMessage(::Ice::Int iceP_session, const ::std::string& iceP_text, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_sendMessage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_sendMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_sendMessage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_text);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_sendMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_sendMessage(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_sendMessage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_hasPermission(::Ice::Int iceP_session, ::Ice::Int iceP_channelid, ::Ice::Int iceP_perm, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_hasPermission_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_hasPermission_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_hasPermission_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        ostr->write(iceP_perm);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_hasPermission_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::MumbleServer::Server::end_hasPermission(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_hasPermission_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_effectivePermissions(::Ice::Int iceP_session, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_effectivePermissions_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_effectivePermissions_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_effectivePermissions_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_effectivePermissions_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_effectivePermissions(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_effectivePermissions_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_addContextCallback(::Ice::Int iceP_session, const ::std::string& iceP_action, const ::std::string& iceP_text, const ::MumbleServer::ServerContextCallbackPrx& iceP_cb, ::Ice::Int iceP_ctx, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addContextCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_addContextCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_addContextCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_action);
        ostr->write(iceP_text);
        ostr->write(iceP_cb);
        ostr->write(iceP_ctx);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_addContextCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_addContextCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_addContextCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_removeContextCallback(const ::MumbleServer::ServerContextCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeContextCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_removeContextCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_removeContextCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_removeContextCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_removeContextCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_removeContextCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getChannelState(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getChannelState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getChannelState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getChannelState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getChannelState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::Channel
IceProxy::MumbleServer::Server::end_getChannelState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getChannelState_name);
    ::MumbleServer::Channel ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setChannelState(const ::MumbleServer::Channel& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setChannelState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setChannelState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setChannelState_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setChannelState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setChannelState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setChannelState_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::NestingLimitException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_removeChannel(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_removeChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_removeChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_removeChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_removeChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_removeChannel_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_addChannel(const ::std::string& iceP_name, ::Ice::Int iceP_parent, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_addChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_addChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_parent);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_addChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_addChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_addChannel_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::NestingLimitException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_sendMessageChannel(::Ice::Int iceP_channelid, bool iceP_tree, const ::std::string& iceP_text, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_sendMessageChannel_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_sendMessageChannel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_sendMessageChannel_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_tree);
        ostr->write(iceP_text);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_sendMessageChannel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_sendMessageChannel(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_sendMessageChannel_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getACL(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getACL_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getACL_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getACL_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getACL_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_getACL(::MumbleServer::ACLList& iceP_acls, ::MumbleServer::GroupList& iceP_groups, bool& iceP_inherit, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    result->_endReadParams();
}

void IceProxy::MumbleServer::Server::_iceI_end_getACL(::MumbleServer::ACLList& iceP_acls, ::MumbleServer::GroupList& iceP_groups, bool& iceP_inherit, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setACL(::Ice::Int iceP_channelid, const ::MumbleServer::ACLList& iceP_acls, const ::MumbleServer::GroupList& iceP_groups, bool iceP_inherit, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setACL_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setACL_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setACL_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_acls);
        ostr->write(iceP_groups);
        ostr->write(iceP_inherit);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setACL_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setACL(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setACL_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_addUserToGroup(::Ice::Int iceP_channelid, ::Ice::Int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_addUserToGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_addUserToGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_addUserToGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_session);
        ostr->write(iceP_group);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_addUserToGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_addUserToGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_addUserToGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_removeUserFromGroup(::Ice::Int iceP_channelid, ::Ice::Int iceP_session, const ::std::string& iceP_group, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_removeUserFromGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_removeUserFromGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_removeUserFromGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_session);
        ostr->write(iceP_group);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_removeUserFromGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_removeUserFromGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_removeUserFromGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidChannelException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_redirectWhisperGroup(::Ice::Int iceP_session, const ::std::string& iceP_source, const ::std::string& iceP_target, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_redirectWhisperGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_redirectWhisperGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_redirectWhisperGroup_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_session);
        ostr->write(iceP_source);
        ostr->write(iceP_target);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_redirectWhisperGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_redirectWhisperGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_redirectWhisperGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSessionException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getUserNames(const ::MumbleServer::IdList& iceP_ids, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUserNames_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getUserNames_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getUserNames_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_ids);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getUserNames_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::NameMap
IceProxy::MumbleServer::Server::end_getUserNames(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getUserNames_name);
    ::MumbleServer::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getUserIds(const ::MumbleServer::NameList& iceP_names, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUserIds_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getUserIds_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getUserIds_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_names);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getUserIds_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::IdMap
IceProxy::MumbleServer::Server::end_getUserIds(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getUserIds_name);
    ::MumbleServer::IdMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_registerUser(const ::MumbleServer::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_registerUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_registerUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_registerUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_registerUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_registerUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_registerUser_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_unregisterUser(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_unregisterUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_unregisterUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_unregisterUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_unregisterUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_unregisterUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_unregisterUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_updateRegistration(::Ice::Int iceP_userid, const ::MumbleServer::UserInfoMap& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_updateRegistration_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_updateRegistration_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_updateRegistration_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_updateRegistration_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_updateRegistration(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_updateRegistration_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getRegistration(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getRegistration_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getRegistration_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getRegistration_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getRegistration_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::UserInfoMap
IceProxy::MumbleServer::Server::end_getRegistration(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getRegistration_name);
    ::MumbleServer::UserInfoMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getRegisteredUsers(const ::std::string& iceP_filter, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getRegisteredUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getRegisteredUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getRegisteredUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_filter);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getRegisteredUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::NameMap
IceProxy::MumbleServer::Server::end_getRegisteredUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getRegisteredUsers_name);
    ::MumbleServer::NameMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_verifyPassword(const ::std::string& iceP_name, const ::std::string& iceP_pw, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_verifyPassword_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_verifyPassword_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_verifyPassword_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_pw);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_verifyPassword_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_verifyPassword(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_verifyPassword_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getTexture(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::Texture
IceProxy::MumbleServer::Server::end_getTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getTexture_name);
    ::MumbleServer::Texture ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setTexture(::Ice::Int iceP_userid, const ::MumbleServer::Texture& iceP_tex, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_setTexture_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setTexture_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setTexture_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_tex);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setTexture_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setTexture(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_setTexture_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidTextureException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidUserException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getUptime(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getUptime_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getUptime_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getUptime_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Server_getUptime_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Server::end_getUptime(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getUptime_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_updateCertificate(const ::std::string& iceP_certificate, const ::std::string& iceP_privateKey, const ::std::string& iceP_passphrase, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_updateCertificate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_updateCertificate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_updateCertificate_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_certificate);
        ostr->write(iceP_privateKey);
        ostr->write(iceP_passphrase);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_updateCertificate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_updateCertificate(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_updateCertificate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidInputDataException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::MumbleServer::ServerBootedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_startListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_startListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_startListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_startListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_startListening(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_Server_startListening_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_stopListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_stopListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_stopListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_stopListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_stopListening(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_Server_stopListening_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_isListening(::Ice::Int iceP_userid, ::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_isListening_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_isListening_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_isListening_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_isListening_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::MumbleServer::Server::end_isListening(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_isListening_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getListeningChannels(::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListeningChannels_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getListeningChannels_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getListeningChannels_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getListeningChannels_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::IntList
IceProxy::MumbleServer::Server::end_getListeningChannels(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getListeningChannels_name);
    ::MumbleServer::IntList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getListeningUsers(::Ice::Int iceP_channelid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListeningUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getListeningUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getListeningUsers_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getListeningUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::IntList
IceProxy::MumbleServer::Server::end_getListeningUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getListeningUsers_name);
    ::MumbleServer::IntList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_getListenerVolumeAdjustment(::Ice::Int iceP_channelid, ::Ice::Int iceP_userid, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Server_getListenerVolumeAdjustment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_getListenerVolumeAdjustment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_getListenerVolumeAdjustment_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_userid);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_getListenerVolumeAdjustment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Float
IceProxy::MumbleServer::Server::end_getListenerVolumeAdjustment(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Server_getListenerVolumeAdjustment_name);
    ::Ice::Float ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_setListenerVolumeAdjustment(::Ice::Int iceP_channelid, ::Ice::Int iceP_userid, ::Ice::Float iceP_volumeAdjustment, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_setListenerVolumeAdjustment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_setListenerVolumeAdjustment_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_channelid);
        ostr->write(iceP_userid);
        ostr->write(iceP_volumeAdjustment);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_setListenerVolumeAdjustment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_setListenerVolumeAdjustment(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_Server_setListenerVolumeAdjustment_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Server::_iceI_begin_sendWelcomeMessage(const ::MumbleServer::IdList& iceP_receiverUserIDs, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Server_sendWelcomeMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Server_sendWelcomeMessage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_receiverUserIDs);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Server_sendWelcomeMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Server::end_sendWelcomeMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_Server_sendWelcomeMessage_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::Server::_newInstance() const
{
    return new Server;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::Server::ice_staticId()
{
    return ::MumbleServer::Server::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(MetaCallback* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MetaCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MetaCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::MetaCallback::_iceI_begin_started(const ::MumbleServer::ServerPrx& iceP_srv, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_MetaCallback_started_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_MetaCallback_started_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_srv);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_MetaCallback_started_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::MetaCallback::end_started(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_MetaCallback_started_name);
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::MetaCallback::_iceI_begin_stopped(const ::MumbleServer::ServerPrx& iceP_srv, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_MetaCallback_stopped_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_MetaCallback_stopped_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_srv);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_MetaCallback_stopped_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::MetaCallback::end_stopped(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_MumbleServer_MetaCallback_stopped_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::MetaCallback::_newInstance() const
{
    return new MetaCallback;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::MetaCallback::ice_staticId()
{
    return ::MumbleServer::MetaCallback::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::MumbleServer::upCast(Meta* p) { return p; }

void
::IceProxy::MumbleServer::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Meta>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Meta;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getServer(::Ice::Int iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getServer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getServer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getServer_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Meta_getServer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ServerPrx
IceProxy::MumbleServer::Meta::end_getServer(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getServer_name);
    ::MumbleServer::ServerPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_newServer(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_newServer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_newServer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_newServer_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_newServer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ServerPrx
IceProxy::MumbleServer::Meta::end_newServer(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_newServer_name);
    ::MumbleServer::ServerPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getBootedServers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getBootedServers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getBootedServers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getBootedServers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getBootedServers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ServerList
IceProxy::MumbleServer::Meta::end_getBootedServers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getBootedServers_name);
    ::MumbleServer::ServerList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getAllServers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getAllServers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getAllServers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getAllServers_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getAllServers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ServerList
IceProxy::MumbleServer::Meta::end_getAllServers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getAllServers_name);
    ::MumbleServer::ServerList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getDefaultConf(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getDefaultConf_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getDefaultConf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getDefaultConf_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getDefaultConf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::MumbleServer::ConfigMap
IceProxy::MumbleServer::Meta::end_getDefaultConf(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getDefaultConf_name);
    ::MumbleServer::ConfigMap ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getVersion(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getVersion_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Meta::end_getVersion(::Ice::Int& iceP_major, ::Ice::Int& iceP_minor, ::Ice::Int& iceP_patch, ::std::string& iceP_text, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_major);
    istr->read(iceP_minor);
    istr->read(iceP_patch);
    istr->read(iceP_text);
    result->_endReadParams();
}

void IceProxy::MumbleServer::Meta::_iceI_end_getVersion(::Ice::Int& iceP_major, ::Ice::Int& iceP_minor, ::Ice::Int& iceP_patch, ::std::string& iceP_text, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_major);
    istr->read(iceP_minor);
    istr->read(iceP_patch);
    istr->read(iceP_text);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_addCallback(const ::MumbleServer::MetaCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_addCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_addCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_addCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Meta_addCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Meta::end_addCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_addCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_removeCallback(const ::MumbleServer::MetaCallbackPrx& iceP_cb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_removeCallback_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_removeCallback_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_removeCallback_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cb);
        result->endWriteParams();
        result->invoke(iceC_MumbleServer_Meta_removeCallback_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::MumbleServer::Meta::end_removeCallback(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_removeCallback_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::MumbleServer::InvalidCallbackException&)
        {
            throw;
        }
        catch(const ::MumbleServer::InvalidSecretException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getUptime(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getUptime_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getUptime_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getUptime_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getUptime_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::MumbleServer::Meta::end_getUptime(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getUptime_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getSlice(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getSlice_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getSlice_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getSlice_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getSlice_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::MumbleServer::Meta::end_getSlice(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getSlice_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::MumbleServer::Meta::_iceI_begin_getSliceChecksums(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_MumbleServer_Meta_getSliceChecksums_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_MumbleServer_Meta_getSliceChecksums_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_MumbleServer_Meta_getSliceChecksums_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_MumbleServer_Meta_getSliceChecksums_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::SliceChecksumDict
IceProxy::MumbleServer::Meta::end_getSliceChecksums(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_MumbleServer_Meta_getSliceChecksums_name);
    ::Ice::SliceChecksumDict ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::MumbleServer::Meta::_newInstance() const
{
    return new Meta;
}
/// \endcond

const ::std::string&
IceProxy::MumbleServer::Meta::ice_staticId()
{
    return ::MumbleServer::Meta::ice_staticId();
}

MumbleServer::Tree::~Tree()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(Tree* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
MumbleServer::Tree::ice_clone() const
{
    ::Ice::Object* p = new Tree(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_MumbleServer_Tree_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::Tree"
};

}

bool
MumbleServer::Tree::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_Tree_ids, iceC_MumbleServer_Tree_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::Tree::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_Tree_ids[0], &iceC_MumbleServer_Tree_ids[2]);
}

const ::std::string&
MumbleServer::Tree::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::Tree::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::Tree";
    return typeId;
#else
    return iceC_MumbleServer_Tree_ids[1];
#endif
}

void
MumbleServer::Tree::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::MumbleServer::TreeList::iterator _i0 = children.begin(); _i0 != children.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::MumbleServer::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
MumbleServer::Tree::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Tree, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::Tree::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Tree, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::MumbleServer::Tree> iceC_MumbleServer_Tree_init("::MumbleServer::Tree");
}

::Ice::ValueFactoryPtr
MumbleServer::Tree::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::MumbleServer::Tree::ice_staticId());
}

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(TreePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TreePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Tree::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::ServerCallback::~ServerCallback()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(ServerCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerCallback"
};

}

bool
MumbleServer::ServerCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerCallback_ids, iceC_MumbleServer_ServerCallback_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::ServerCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_ServerCallback_ids[0], &iceC_MumbleServer_ServerCallback_ids[2]);
}

const ::std::string&
MumbleServer::ServerCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::ServerCallback";
    return typeId;
#else
    return iceC_MumbleServer_ServerCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userConnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userConnected(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userDisconnected(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userDisconnected(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->userStateChanged(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_userTextMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    TextMessage iceP_message;
    istr->read(iceP_state);
    istr->read(iceP_message);
    inS.endReadParams();
    this->userTextMessage(iceP_state, iceP_message, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelCreated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelCreated(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelRemoved(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceD_channelStateChanged(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->channelStateChanged(iceP_state, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerCallback_all[] =
{
    "channelCreated",
    "channelRemoved",
    "channelStateChanged",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "userConnected",
    "userDisconnected",
    "userStateChanged",
    "userTextMessage"
};

}

/// \cond INTERNAL
bool
MumbleServer::ServerCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerCallback_all, iceC_MumbleServer_ServerCallback_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerCallback_all)
    {
        case 0:
        {
            return _iceD_channelCreated(in, current);
        }
        case 1:
        {
            return _iceD_channelRemoved(in, current);
        }
        case 2:
        {
            return _iceD_channelStateChanged(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_userConnected(in, current);
        }
        case 8:
        {
            return _iceD_userDisconnected(in, current);
        }
        case 9:
        {
            return _iceD_userStateChanged(in, current);
        }
        case 10:
        {
            return _iceD_userTextMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::ServerCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::ServerCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(ServerCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerCallback::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::ServerContextCallback::~ServerContextCallback()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(ServerContextCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerContextCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerContextCallback"
};

}

bool
MumbleServer::ServerContextCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerContextCallback_ids, iceC_MumbleServer_ServerContextCallback_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::ServerContextCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_ServerContextCallback_ids[0], &iceC_MumbleServer_ServerContextCallback_ids[2]);
}

const ::std::string&
MumbleServer::ServerContextCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerContextCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::ServerContextCallback";
    return typeId;
#else
    return iceC_MumbleServer_ServerContextCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::ServerContextCallback::_iceD_contextAction(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_action;
    User iceP_usr;
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_action);
    istr->read(iceP_usr);
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->contextAction(iceP_action, iceP_usr, iceP_session, iceP_channelid, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerContextCallback_all[] =
{
    "contextAction",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
MumbleServer::ServerContextCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerContextCallback_all, iceC_MumbleServer_ServerContextCallback_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerContextCallback_all)
    {
        case 0:
        {
            return _iceD_contextAction(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::ServerContextCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerContextCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::ServerContextCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerContextCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(ServerContextCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerContextCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerContextCallback::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::ServerAuthenticator::~ServerAuthenticator()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(ServerAuthenticator* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerAuthenticator_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::ServerAuthenticator"
};

}

bool
MumbleServer::ServerAuthenticator::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerAuthenticator_ids, iceC_MumbleServer_ServerAuthenticator_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::ServerAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_ServerAuthenticator_ids[0], &iceC_MumbleServer_ServerAuthenticator_ids[2]);
}

const ::std::string&
MumbleServer::ServerAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerAuthenticator::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::ServerAuthenticator";
    return typeId;
#else
    return iceC_MumbleServer_ServerAuthenticator_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_authenticate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    CertificateList iceP_certificates;
    ::std::string iceP_certhash;
    bool iceP_certstrong;
    istr->read(iceP_name);
    istr->read(iceP_pw);
    istr->read(iceP_certificates);
    istr->read(iceP_certhash);
    istr->read(iceP_certstrong);
    inS.endReadParams();
    ::std::string iceP_newname;
    GroupNameList iceP_groups;
    ::Ice::Int ret = this->authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, iceP_newname, iceP_groups, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_newname);
    ostr->write(iceP_groups);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_getInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    UserInfoMap iceP_info;
    bool ret = this->getInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_info);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_nameToId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    ::Ice::Int ret = this->nameToId(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_idToName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ::std::string ret = this->idToName(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceD_idToTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    Texture ret = this->idToTexture(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId"
};

}

/// \cond INTERNAL
bool
MumbleServer::ServerAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerAuthenticator_all, iceC_MumbleServer_ServerAuthenticator_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerAuthenticator_all)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_idToName(in, current);
        }
        case 7:
        {
            return _iceD_idToTexture(in, current);
        }
        case 8:
        {
            return _iceD_nameToId(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::ServerAuthenticator::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerAuthenticator, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::ServerAuthenticator::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerAuthenticator, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(ServerAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerAuthenticator::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::ServerUpdatingAuthenticator::~ServerUpdatingAuthenticator()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(ServerUpdatingAuthenticator* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_ids[3] =
{
    "::Ice::Object",
    "::MumbleServer::ServerAuthenticator",
    "::MumbleServer::ServerUpdatingAuthenticator"
};

}

bool
MumbleServer::ServerUpdatingAuthenticator::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_ServerUpdatingAuthenticator_ids, iceC_MumbleServer_ServerUpdatingAuthenticator_ids + 3, s);
}

::std::vector< ::std::string>
MumbleServer::ServerUpdatingAuthenticator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_ServerUpdatingAuthenticator_ids[0], &iceC_MumbleServer_ServerUpdatingAuthenticator_ids[3]);
}

const ::std::string&
MumbleServer::ServerUpdatingAuthenticator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::ServerUpdatingAuthenticator::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::ServerUpdatingAuthenticator";
    return typeId;
#else
    return iceC_MumbleServer_ServerUpdatingAuthenticator_ids[2];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    ::Ice::Int ret = this->registerUser(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ::Ice::Int ret = this->unregisterUser(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->read(iceP_filter);
    inS.endReadParams();
    NameMap ret = this->getRegisteredUsers(iceP_filter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    UserInfoMap iceP_info;
    istr->read(iceP_id);
    istr->read(iceP_info);
    inS.endReadParams();
    ::Ice::Int ret = this->setInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    Texture iceP_tex;
    istr->read(iceP_id);
    istr->read(iceP_tex);
    inS.endReadParams();
    ::Ice::Int ret = this->setTexture(iceP_id, iceP_tex, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_ServerUpdatingAuthenticator_all[] =
{
    "authenticate",
    "getInfo",
    "getRegisteredUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "idToName",
    "idToTexture",
    "nameToId",
    "registerUser",
    "setInfo",
    "setTexture",
    "unregisterUser"
};

}

/// \cond INTERNAL
bool
MumbleServer::ServerUpdatingAuthenticator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_ServerUpdatingAuthenticator_all, iceC_MumbleServer_ServerUpdatingAuthenticator_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_ServerUpdatingAuthenticator_all)
    {
        case 0:
        {
            return _iceD_authenticate(in, current);
        }
        case 1:
        {
            return _iceD_getInfo(in, current);
        }
        case 2:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_idToName(in, current);
        }
        case 8:
        {
            return _iceD_idToTexture(in, current);
        }
        case 9:
        {
            return _iceD_nameToId(in, current);
        }
        case 10:
        {
            return _iceD_registerUser(in, current);
        }
        case 11:
        {
            return _iceD_setInfo(in, current);
        }
        case 12:
        {
            return _iceD_setTexture(in, current);
        }
        case 13:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::ServerUpdatingAuthenticator::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ServerUpdatingAuthenticator, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::ServerUpdatingAuthenticator::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ServerUpdatingAuthenticator, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(ServerUpdatingAuthenticatorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerUpdatingAuthenticatorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ServerUpdatingAuthenticator::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::Server::~Server()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(Server* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_Server_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::Server"
};

}

bool
MumbleServer::Server::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_Server_ids, iceC_MumbleServer_Server_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_Server_ids[0], &iceC_MumbleServer_Server_ids[2]);
}

const ::std::string&
MumbleServer::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::Server::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::Server";
    return typeId;
#else
    return iceC_MumbleServer_Server_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_isRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->isRunning_async(new IceAsync::MumbleServer::AMD_Server_isRunning(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_start(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->start_async(new IceAsync::MumbleServer::AMD_Server_start(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_stop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->stop_async(new IceAsync::MumbleServer::AMD_Server_stop(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_delete(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->delete_async(new IceAsync::MumbleServer::AMD_Server_delete(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_id(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->id_async(new IceAsync::MumbleServer::AMD_Server_id(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->addCallback_async(new IceAsync::MumbleServer::AMD_Server_addCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeCallback_async(new IceAsync::MumbleServer::AMD_Server_removeCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setAuthenticator(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerAuthenticatorPrx iceP_auth;
    istr->read(iceP_auth);
    inS.endReadParams();
    this->setAuthenticator_async(new IceAsync::MumbleServer::AMD_Server_setAuthenticator(inS), iceP_auth, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->read(iceP_key);
    inS.endReadParams();
    this->getConf_async(new IceAsync::MumbleServer::AMD_Server_getConf(inS), iceP_key, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getAllConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getAllConf_async(new IceAsync::MumbleServer::AMD_Server_getAllConf(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->read(iceP_key);
    istr->read(iceP_value);
    inS.endReadParams();
    this->setConf_async(new IceAsync::MumbleServer::AMD_Server_setConf(inS), iceP_key, iceP_value, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setSuperuserPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_pw;
    istr->read(iceP_pw);
    inS.endReadParams();
    this->setSuperuserPassword_async(new IceAsync::MumbleServer::AMD_Server_setSuperuserPassword(inS), iceP_pw, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_first;
    ::Ice::Int iceP_last;
    istr->read(iceP_first);
    istr->read(iceP_last);
    inS.endReadParams();
    this->getLog_async(new IceAsync::MumbleServer::AMD_Server_getLog(inS), iceP_first, iceP_last, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getLogLen(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getLogLen_async(new IceAsync::MumbleServer::AMD_Server_getLogLen(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUsers_async(new IceAsync::MumbleServer::AMD_Server_getUsers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getChannels_async(new IceAsync::MumbleServer::AMD_Server_getChannels(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getCertificateList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    istr->read(iceP_session);
    inS.endReadParams();
    this->getCertificateList_async(new IceAsync::MumbleServer::AMD_Server_getCertificateList(inS), iceP_session, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getTree(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getTree_async(new IceAsync::MumbleServer::AMD_Server_getTree(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getBans_async(new IceAsync::MumbleServer::AMD_Server_getBans(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setBans(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BanList iceP_bans;
    istr->read(iceP_bans);
    inS.endReadParams();
    this->setBans_async(new IceAsync::MumbleServer::AMD_Server_setBans(inS), iceP_bans, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_kickUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_reason;
    istr->read(iceP_session);
    istr->read(iceP_reason);
    inS.endReadParams();
    this->kickUser_async(new IceAsync::MumbleServer::AMD_Server_kickUser(inS), iceP_session, iceP_reason, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    istr->read(iceP_session);
    inS.endReadParams();
    this->getState_async(new IceAsync::MumbleServer::AMD_Server_getState(inS), iceP_session, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    User iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->setState_async(new IceAsync::MumbleServer::AMD_Server_setState(inS), iceP_state, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_text;
    istr->read(iceP_session);
    istr->read(iceP_text);
    inS.endReadParams();
    this->sendMessage_async(new IceAsync::MumbleServer::AMD_Server_sendMessage(inS), iceP_session, iceP_text, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_hasPermission(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_perm;
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    istr->read(iceP_perm);
    inS.endReadParams();
    this->hasPermission_async(new IceAsync::MumbleServer::AMD_Server_hasPermission(inS), iceP_session, iceP_channelid, iceP_perm, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_effectivePermissions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_session);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->effectivePermissions_async(new IceAsync::MumbleServer::AMD_Server_effectivePermissions(inS), iceP_session, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_action;
    ::std::string iceP_text;
    ServerContextCallbackPrx iceP_cb;
    ::Ice::Int iceP_ctx;
    istr->read(iceP_session);
    istr->read(iceP_action);
    istr->read(iceP_text);
    istr->read(iceP_cb);
    istr->read(iceP_ctx);
    inS.endReadParams();
    this->addContextCallback_async(new IceAsync::MumbleServer::AMD_Server_addContextCallback(inS), iceP_session, iceP_action, iceP_text, iceP_cb, iceP_ctx, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeContextCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerContextCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeContextCallback_async(new IceAsync::MumbleServer::AMD_Server_removeContextCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getChannelState_async(new IceAsync::MumbleServer::AMD_Server_getChannelState(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setChannelState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Channel iceP_state;
    istr->read(iceP_state);
    inS.endReadParams();
    this->setChannelState_async(new IceAsync::MumbleServer::AMD_Server_setChannelState(inS), iceP_state, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->removeChannel_async(new IceAsync::MumbleServer::AMD_Server_removeChannel(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Int iceP_parent;
    istr->read(iceP_name);
    istr->read(iceP_parent);
    inS.endReadParams();
    this->addChannel_async(new IceAsync::MumbleServer::AMD_Server_addChannel(inS), iceP_name, iceP_parent, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendMessageChannel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    bool iceP_tree;
    ::std::string iceP_text;
    istr->read(iceP_channelid);
    istr->read(iceP_tree);
    istr->read(iceP_text);
    inS.endReadParams();
    this->sendMessageChannel_async(new IceAsync::MumbleServer::AMD_Server_sendMessageChannel(inS), iceP_channelid, iceP_tree, iceP_text, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getACL_async(new IceAsync::MumbleServer::AMD_Server_getACL(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setACL(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ACLList iceP_acls;
    GroupList iceP_groups;
    bool iceP_inherit;
    istr->read(iceP_channelid);
    istr->read(iceP_acls);
    istr->read(iceP_groups);
    istr->read(iceP_inherit);
    inS.endReadParams();
    this->setACL_async(new IceAsync::MumbleServer::AMD_Server_setACL(inS), iceP_channelid, iceP_acls, iceP_groups, iceP_inherit, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_addUserToGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_session;
    ::std::string iceP_group;
    istr->read(iceP_channelid);
    istr->read(iceP_session);
    istr->read(iceP_group);
    inS.endReadParams();
    this->addUserToGroup_async(new IceAsync::MumbleServer::AMD_Server_addUserToGroup(inS), iceP_channelid, iceP_session, iceP_group, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_removeUserFromGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_session;
    ::std::string iceP_group;
    istr->read(iceP_channelid);
    istr->read(iceP_session);
    istr->read(iceP_group);
    inS.endReadParams();
    this->removeUserFromGroup_async(new IceAsync::MumbleServer::AMD_Server_removeUserFromGroup(inS), iceP_channelid, iceP_session, iceP_group, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_redirectWhisperGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_session;
    ::std::string iceP_source;
    ::std::string iceP_target;
    istr->read(iceP_session);
    istr->read(iceP_source);
    istr->read(iceP_target);
    inS.endReadParams();
    this->redirectWhisperGroup_async(new IceAsync::MumbleServer::AMD_Server_redirectWhisperGroup(inS), iceP_session, iceP_source, iceP_target, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUserNames(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IdList iceP_ids;
    istr->read(iceP_ids);
    inS.endReadParams();
    this->getUserNames_async(new IceAsync::MumbleServer::AMD_Server_getUserNames(inS), iceP_ids, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUserIds(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    NameList iceP_names;
    istr->read(iceP_names);
    inS.endReadParams();
    this->getUserIds_async(new IceAsync::MumbleServer::AMD_Server_getUserIds(inS), iceP_names, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    UserInfoMap iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    this->registerUser_async(new IceAsync::MumbleServer::AMD_Server_registerUser(inS), iceP_info, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->unregisterUser_async(new IceAsync::MumbleServer::AMD_Server_unregisterUser(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_updateRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    UserInfoMap iceP_info;
    istr->read(iceP_userid);
    istr->read(iceP_info);
    inS.endReadParams();
    this->updateRegistration_async(new IceAsync::MumbleServer::AMD_Server_updateRegistration(inS), iceP_userid, iceP_info, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getRegistration(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getRegistration_async(new IceAsync::MumbleServer::AMD_Server_getRegistration(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getRegisteredUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_filter;
    istr->read(iceP_filter);
    inS.endReadParams();
    this->getRegisteredUsers_async(new IceAsync::MumbleServer::AMD_Server_getRegisteredUsers(inS), iceP_filter, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_verifyPassword(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_pw;
    istr->read(iceP_name);
    istr->read(iceP_pw);
    inS.endReadParams();
    this->verifyPassword_async(new IceAsync::MumbleServer::AMD_Server_verifyPassword(inS), iceP_name, iceP_pw, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getTexture_async(new IceAsync::MumbleServer::AMD_Server_getTexture(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setTexture(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    Texture iceP_tex;
    istr->read(iceP_userid);
    istr->read(iceP_tex);
    inS.endReadParams();
    this->setTexture_async(new IceAsync::MumbleServer::AMD_Server_setTexture(inS), iceP_userid, iceP_tex, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUptime_async(new IceAsync::MumbleServer::AMD_Server_getUptime(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_updateCertificate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_certificate;
    ::std::string iceP_privateKey;
    ::std::string iceP_passphrase;
    istr->read(iceP_certificate);
    istr->read(iceP_privateKey);
    istr->read(iceP_passphrase);
    inS.endReadParams();
    this->updateCertificate_async(new IceAsync::MumbleServer::AMD_Server_updateCertificate(inS), iceP_certificate, iceP_privateKey, iceP_passphrase, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_startListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->startListening_async(new IceAsync::MumbleServer::AMD_Server_startListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_stopListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->stopListening_async(new IceAsync::MumbleServer::AMD_Server_stopListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_isListening(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    ::Ice::Int iceP_channelid;
    istr->read(iceP_userid);
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->isListening_async(new IceAsync::MumbleServer::AMD_Server_isListening(inS), iceP_userid, iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListeningChannels(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_userid;
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getListeningChannels_async(new IceAsync::MumbleServer::AMD_Server_getListeningChannels(inS), iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListeningUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    istr->read(iceP_channelid);
    inS.endReadParams();
    this->getListeningUsers_async(new IceAsync::MumbleServer::AMD_Server_getListeningUsers(inS), iceP_channelid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_getListenerVolumeAdjustment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_userid;
    istr->read(iceP_channelid);
    istr->read(iceP_userid);
    inS.endReadParams();
    this->getListenerVolumeAdjustment_async(new IceAsync::MumbleServer::AMD_Server_getListenerVolumeAdjustment(inS), iceP_channelid, iceP_userid, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_setListenerVolumeAdjustment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_channelid;
    ::Ice::Int iceP_userid;
    ::Ice::Float iceP_volumeAdjustment;
    istr->read(iceP_channelid);
    istr->read(iceP_userid);
    istr->read(iceP_volumeAdjustment);
    inS.endReadParams();
    this->setListenerVolumeAdjustment_async(new IceAsync::MumbleServer::AMD_Server_setListenerVolumeAdjustment(inS), iceP_channelid, iceP_userid, iceP_volumeAdjustment, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Server::_iceD_sendWelcomeMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IdList iceP_receiverUserIDs;
    istr->read(iceP_receiverUserIDs);
    inS.endReadParams();
    this->sendWelcomeMessage_async(new IceAsync::MumbleServer::AMD_Server_sendWelcomeMessage(inS), iceP_receiverUserIDs, current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_Server_all[] =
{
    "addCallback",
    "addChannel",
    "addContextCallback",
    "addUserToGroup",
    "delete",
    "effectivePermissions",
    "getACL",
    "getAllConf",
    "getBans",
    "getCertificateList",
    "getChannelState",
    "getChannels",
    "getConf",
    "getListenerVolumeAdjustment",
    "getListeningChannels",
    "getListeningUsers",
    "getLog",
    "getLogLen",
    "getRegisteredUsers",
    "getRegistration",
    "getState",
    "getTexture",
    "getTree",
    "getUptime",
    "getUserIds",
    "getUserNames",
    "getUsers",
    "hasPermission",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "id",
    "isListening",
    "isRunning",
    "kickUser",
    "redirectWhisperGroup",
    "registerUser",
    "removeCallback",
    "removeChannel",
    "removeContextCallback",
    "removeUserFromGroup",
    "sendMessage",
    "sendMessageChannel",
    "sendWelcomeMessage",
    "setACL",
    "setAuthenticator",
    "setBans",
    "setChannelState",
    "setConf",
    "setListenerVolumeAdjustment",
    "setState",
    "setSuperuserPassword",
    "setTexture",
    "start",
    "startListening",
    "stop",
    "stopListening",
    "unregisterUser",
    "updateCertificate",
    "updateRegistration",
    "verifyPassword"
};

}

/// \cond INTERNAL
bool
MumbleServer::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_Server_all, iceC_MumbleServer_Server_all + 62, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_Server_all)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_addChannel(in, current);
        }
        case 2:
        {
            return _iceD_addContextCallback(in, current);
        }
        case 3:
        {
            return _iceD_addUserToGroup(in, current);
        }
        case 4:
        {
            return _iceD_delete(in, current);
        }
        case 5:
        {
            return _iceD_effectivePermissions(in, current);
        }
        case 6:
        {
            return _iceD_getACL(in, current);
        }
        case 7:
        {
            return _iceD_getAllConf(in, current);
        }
        case 8:
        {
            return _iceD_getBans(in, current);
        }
        case 9:
        {
            return _iceD_getCertificateList(in, current);
        }
        case 10:
        {
            return _iceD_getChannelState(in, current);
        }
        case 11:
        {
            return _iceD_getChannels(in, current);
        }
        case 12:
        {
            return _iceD_getConf(in, current);
        }
        case 13:
        {
            return _iceD_getListenerVolumeAdjustment(in, current);
        }
        case 14:
        {
            return _iceD_getListeningChannels(in, current);
        }
        case 15:
        {
            return _iceD_getListeningUsers(in, current);
        }
        case 16:
        {
            return _iceD_getLog(in, current);
        }
        case 17:
        {
            return _iceD_getLogLen(in, current);
        }
        case 18:
        {
            return _iceD_getRegisteredUsers(in, current);
        }
        case 19:
        {
            return _iceD_getRegistration(in, current);
        }
        case 20:
        {
            return _iceD_getState(in, current);
        }
        case 21:
        {
            return _iceD_getTexture(in, current);
        }
        case 22:
        {
            return _iceD_getTree(in, current);
        }
        case 23:
        {
            return _iceD_getUptime(in, current);
        }
        case 24:
        {
            return _iceD_getUserIds(in, current);
        }
        case 25:
        {
            return _iceD_getUserNames(in, current);
        }
        case 26:
        {
            return _iceD_getUsers(in, current);
        }
        case 27:
        {
            return _iceD_hasPermission(in, current);
        }
        case 28:
        {
            return _iceD_ice_id(in, current);
        }
        case 29:
        {
            return _iceD_ice_ids(in, current);
        }
        case 30:
        {
            return _iceD_ice_isA(in, current);
        }
        case 31:
        {
            return _iceD_ice_ping(in, current);
        }
        case 32:
        {
            return _iceD_id(in, current);
        }
        case 33:
        {
            return _iceD_isListening(in, current);
        }
        case 34:
        {
            return _iceD_isRunning(in, current);
        }
        case 35:
        {
            return _iceD_kickUser(in, current);
        }
        case 36:
        {
            return _iceD_redirectWhisperGroup(in, current);
        }
        case 37:
        {
            return _iceD_registerUser(in, current);
        }
        case 38:
        {
            return _iceD_removeCallback(in, current);
        }
        case 39:
        {
            return _iceD_removeChannel(in, current);
        }
        case 40:
        {
            return _iceD_removeContextCallback(in, current);
        }
        case 41:
        {
            return _iceD_removeUserFromGroup(in, current);
        }
        case 42:
        {
            return _iceD_sendMessage(in, current);
        }
        case 43:
        {
            return _iceD_sendMessageChannel(in, current);
        }
        case 44:
        {
            return _iceD_sendWelcomeMessage(in, current);
        }
        case 45:
        {
            return _iceD_setACL(in, current);
        }
        case 46:
        {
            return _iceD_setAuthenticator(in, current);
        }
        case 47:
        {
            return _iceD_setBans(in, current);
        }
        case 48:
        {
            return _iceD_setChannelState(in, current);
        }
        case 49:
        {
            return _iceD_setConf(in, current);
        }
        case 50:
        {
            return _iceD_setListenerVolumeAdjustment(in, current);
        }
        case 51:
        {
            return _iceD_setState(in, current);
        }
        case 52:
        {
            return _iceD_setSuperuserPassword(in, current);
        }
        case 53:
        {
            return _iceD_setTexture(in, current);
        }
        case 54:
        {
            return _iceD_start(in, current);
        }
        case 55:
        {
            return _iceD_startListening(in, current);
        }
        case 56:
        {
            return _iceD_stop(in, current);
        }
        case 57:
        {
            return _iceD_stopListening(in, current);
        }
        case 58:
        {
            return _iceD_unregisterUser(in, current);
        }
        case 59:
        {
            return _iceD_updateCertificate(in, current);
        }
        case 60:
        {
            return _iceD_updateRegistration(in, current);
        }
        case 61:
        {
            return _iceD_verifyPassword(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::Server::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Server, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::Server::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Server, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(ServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Server::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::MetaCallback::~MetaCallback()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(MetaCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_MetaCallback_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::MetaCallback"
};

}

bool
MumbleServer::MetaCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_MetaCallback_ids, iceC_MumbleServer_MetaCallback_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::MetaCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_MetaCallback_ids[0], &iceC_MumbleServer_MetaCallback_ids[2]);
}

const ::std::string&
MumbleServer::MetaCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::MetaCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::MetaCallback";
    return typeId;
#else
    return iceC_MumbleServer_MetaCallback_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceD_started(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerPrx iceP_srv;
    istr->read(iceP_srv);
    inS.endReadParams();
    this->started(iceP_srv, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceD_stopped(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ServerPrx iceP_srv;
    istr->read(iceP_srv);
    inS.endReadParams();
    this->stopped(iceP_srv, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_MetaCallback_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "started",
    "stopped"
};

}

/// \cond INTERNAL
bool
MumbleServer::MetaCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_MetaCallback_all, iceC_MumbleServer_MetaCallback_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_MetaCallback_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_started(in, current);
        }
        case 5:
        {
            return _iceD_stopped(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::MetaCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MetaCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::MetaCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MetaCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(MetaCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MetaCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MetaCallback::ice_staticId(), v);
    }
}
/// \endcond

MumbleServer::Meta::~Meta()
{
}

/// \cond INTERNAL
::Ice::Object* MumbleServer::upCast(Meta* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_Meta_ids[2] =
{
    "::Ice::Object",
    "::MumbleServer::Meta"
};

}

bool
MumbleServer::Meta::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_MumbleServer_Meta_ids, iceC_MumbleServer_Meta_ids + 2, s);
}

::std::vector< ::std::string>
MumbleServer::Meta::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_MumbleServer_Meta_ids[0], &iceC_MumbleServer_Meta_ids[2]);
}

const ::std::string&
MumbleServer::Meta::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
MumbleServer::Meta::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::MumbleServer::Meta";
    return typeId;
#else
    return iceC_MumbleServer_Meta_ids[1];
#endif
}

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    this->getServer_async(new IceAsync::MumbleServer::AMD_Meta_getServer(inS), iceP_id, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_newServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->newServer_async(new IceAsync::MumbleServer::AMD_Meta_newServer(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getBootedServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getBootedServers_async(new IceAsync::MumbleServer::AMD_Meta_getBootedServers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getAllServers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getAllServers_async(new IceAsync::MumbleServer::AMD_Meta_getAllServers(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getDefaultConf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getDefaultConf_async(new IceAsync::MumbleServer::AMD_Meta_getDefaultConf(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getVersion_async(new IceAsync::MumbleServer::AMD_Meta_getVersion(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_addCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MetaCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->addCallback_async(new IceAsync::MumbleServer::AMD_Meta_addCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_removeCallback(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MetaCallbackPrx iceP_cb;
    istr->read(iceP_cb);
    inS.endReadParams();
    this->removeCallback_async(new IceAsync::MumbleServer::AMD_Meta_removeCallback(inS), iceP_cb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getUptime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getUptime_async(new IceAsync::MumbleServer::AMD_Meta_getUptime(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getSlice(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getSlice_async(new IceAsync::MumbleServer::AMD_Meta_getSlice(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceD_getSliceChecksums(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->getSliceChecksums_async(new IceAsync::MumbleServer::AMD_Meta_getSliceChecksums(inS), current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_MumbleServer_Meta_all[] =
{
    "addCallback",
    "getAllServers",
    "getBootedServers",
    "getDefaultConf",
    "getServer",
    "getSlice",
    "getSliceChecksums",
    "getUptime",
    "getVersion",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newServer",
    "removeCallback"
};

}

/// \cond INTERNAL
bool
MumbleServer::Meta::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_MumbleServer_Meta_all, iceC_MumbleServer_Meta_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_MumbleServer_Meta_all)
    {
        case 0:
        {
            return _iceD_addCallback(in, current);
        }
        case 1:
        {
            return _iceD_getAllServers(in, current);
        }
        case 2:
        {
            return _iceD_getBootedServers(in, current);
        }
        case 3:
        {
            return _iceD_getDefaultConf(in, current);
        }
        case 4:
        {
            return _iceD_getServer(in, current);
        }
        case 5:
        {
            return _iceD_getSlice(in, current);
        }
        case 6:
        {
            return _iceD_getSliceChecksums(in, current);
        }
        case 7:
        {
            return _iceD_getUptime(in, current);
        }
        case 8:
        {
            return _iceD_getVersion(in, current);
        }
        case 9:
        {
            return _iceD_ice_id(in, current);
        }
        case 10:
        {
            return _iceD_ice_ids(in, current);
        }
        case 11:
        {
            return _iceD_ice_isA(in, current);
        }
        case 12:
        {
            return _iceD_ice_ping(in, current);
        }
        case 13:
        {
            return _iceD_newServer(in, current);
        }
        case 14:
        {
            return _iceD_removeCallback(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
MumbleServer::Meta::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Meta, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
MumbleServer::Meta::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Meta, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
MumbleServer::_icePatchObjectPtr(MetaPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MetaPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Meta::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

namespace
{

const char* iceSliceChecksums[] =
{
    "::MumbleServer::ACL", "157797fb27cda83faec7e5374284e275",
    "::MumbleServer::ACLList", "11e99d3da9c9a3cacf599b1045d88370",
    "::MumbleServer::Ban", "a5a9cd583bc04dcdca89bff31e2e1294",
    "::MumbleServer::BanList", "e94e7a8b59e24ccc5ee2fbd41753a2a7",
    "::MumbleServer::CertificateDer", "bda5350e8ec40eef1cae7c2b3c616cf",
    "::MumbleServer::CertificateList", "9626e55ba4d813d9374b686dfb315e",
    "::MumbleServer::Channel", "e7ae81e73bbf7fb4a575d8eedca8458",
    "::MumbleServer::ChannelInfo", "1e1c915adb3475dd6aa6943aff139d7c",
    "::MumbleServer::ChannelList", "a4e0625082768612d43fc41563533c8b",
    "::MumbleServer::ChannelMap", "78fcab14097578194791985595a084",
    "::MumbleServer::ConfigMap", "a959102c70f61ff099b044a145ba2a",
    "::MumbleServer::ContextChannel", "d031ddb65dbaea316b6718ffa867852",
    "::MumbleServer::ContextServer", "36637f606caa3dfe7a88816f3d1d4b4",
    "::MumbleServer::ContextUser", "928e6ca841dc5467d671cc7e94a47b1",
    "::MumbleServer::Group", "4f30a28dc2571d11a4361e55d2bf5923",
    "::MumbleServer::GroupList", "f3b3fa68671f8411d9bd34524ffc153b",
    "::MumbleServer::GroupNameList", "3129349326861d482a77548514a44ea9",
    "::MumbleServer::IdList", "ee9f8c35179c12487ff62e359b7f267b",
    "::MumbleServer::IdMap", "36f07840567acf5a1a182b80cc4ec4c8",
    "::MumbleServer::IntList", "6f1c32278d7993b8e7fcab62838cfa6",
    "::MumbleServer::InvalidCallbackException", "278bf6bd2dd1e7e5dcbdc482c82bbe35",
    "::MumbleServer::InvalidChannelException", "dba473da2b7247f2ae1b2fab0993848",
    "::MumbleServer::InvalidInputDataException", "9e862d16b7a2e897ae8ce8c98a5081a1",
    "::MumbleServer::InvalidSecretException", "c570ebf17f803b19dbb5b2a9b7e147",
    "::MumbleServer::InvalidServerException", "9a9fdd40ba92e699df60753cda58a9",
    "::MumbleServer::InvalidSessionException", "433b17dcfda4e2f75b56966443c88f64",
    "::MumbleServer::InvalidTextureException", "5ade1dd53f39a22f6c2262f3716570",
    "::MumbleServer::InvalidUserException", "37b9da856944847678f0f9c76ce5b9df",
    "::MumbleServer::LogEntry", "baf7375450f0cf5a4221ac1080297efb",
    "::MumbleServer::LogList", "72dc8f688160bad9a94a44522b7b6191",
    "::MumbleServer::Meta", "f928871061a49894ed76a5e9afd8b3c2",
    "::MumbleServer::MetaCallback", "3b7339506c31bda4cbeb7970f6fbdce",
    "::MumbleServer::MurmurException", "f14e757fac3ec91e3eb581beaf8d1af",
    "::MumbleServer::NameList", "492b93e2b12d2bd7f61f719a67b8623b",
    "::MumbleServer::NameMap", "8eb7985198a0add716b9462cbdd8c",
    "::MumbleServer::NestingLimitException", "b11ded4184541bbefce6e879b151638f",
    "::MumbleServer::NetAddress", "fe2a565d478baf1e5e2168ca4492d9d",
    "::MumbleServer::PermissionBan", "ac198d670d743c882937073eae3247",
    "::MumbleServer::PermissionEnter", "54fa28c949285c187f4df657b087b8",
    "::MumbleServer::PermissionKick", "15a8e0bcd0862dba4b5b72550f09aad",
    "::MumbleServer::PermissionLinkChannel", "992d2978f5eb8c5c5c8ec68aee4f890",
    "::MumbleServer::PermissionMakeChannel", "7cb412acce465d84c9a11bc5cd43e66",
    "::MumbleServer::PermissionMakeTempChannel", "beeec37912c744f855149ab30608344",
    "::MumbleServer::PermissionMove", "19f25e8a3ccabbbdf7316a675d6cc87",
    "::MumbleServer::PermissionMuteDeafen", "53c56b4bd8cf231a4090ef24ed893939",
    "::MumbleServer::PermissionRegister", "d0c4e13de6abc868b79cf01bb7d5c1ad",
    "::MumbleServer::PermissionRegisterSelf", "3a9718827e1cdc13b1fde4a724df8",
    "::MumbleServer::PermissionSpeak", "cfd814f27bac13db9c9a342a0512a4b",
    "::MumbleServer::PermissionTextMessage", "b5d36eeecdffc56a3a72854a1469145b",
    "::MumbleServer::PermissionTraverse", "37f12b9bb96c0d07a7c45e1bfef0fe",
    "::MumbleServer::PermissionWhisper", "dddf47c35e992f8cd868c4321f9bcb",
    "::MumbleServer::PermissionWrite", "a939b87d29f9fff8b2f957b3e4b121c0",
    "::MumbleServer::ResetUserContent", "144ba8653415acdee3d3f946a18058",
    "::MumbleServer::Server", "c859ba8ac35f723da5bf631ca7c5a26",
    "::MumbleServer::ServerAuthenticator", "588e4f7f6c31e7bebbc388b1343b86",
    "::MumbleServer::ServerBootedException", "d5e3e6f31eb8dac43e36186f59f2b1f",
    "::MumbleServer::ServerCallback", "c6925adf5c867863d8b1c11d6cc3",
    "::MumbleServer::ServerContextCallback", "83f3ed9f686d5df914e04a57b570f25d",
    "::MumbleServer::ServerFailureException", "7c885c13625e83a4b7731b48f6dbe2",
    "::MumbleServer::ServerList", "6e7b88da2fd3e5d296178aceca55276",
    "::MumbleServer::ServerUpdatingAuthenticator", "b01649b6e69c085efd0137c4534d87b",
    "::MumbleServer::TextMessage", "7fe11d57e63367253c0ec5692441a",
    "::MumbleServer::Texture", "141dd3bb5aa45668e290153de4e8a23c",
    "::MumbleServer::Tree", "c92169edbf14febef3dd4d11373c086",
    "::MumbleServer::TreeList", "54fb50b83cbdce3a46c86994acf62f",
    "::MumbleServer::User", "74ec7daea8b1c30f74cfaf08bd16b2",
    "::MumbleServer::UserInfo", "3c1a3c8ac61325a80f23f21e5466294",
    "::MumbleServer::UserInfoMap", "4ec636e19df849d64563a9e836e2768",
    "::MumbleServer::UserList", "7274fcc9d23b31dfee87f56848e0ef",
    "::MumbleServer::UserMap", "15db3be62794955cd21261408bb6cbb1",
    "::MumbleServer::WriteOnlyException", "8eb3be3bc10badcfb4cf26136c3fba5",
    0
};
const IceInternal::SliceChecksumInit iceSliceChecksumInit(iceSliceChecksums);

}

#endif
